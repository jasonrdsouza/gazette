{
    "articles": [
        {
            "content": [
                "<header>\n  <h1>Wrapping Code Comments</h1>\n  <time class=\"meta\" datetime=\"2026-02-21\">Feb 21, 2026</time>\n</header>\n<p>I was today years old when I realized that:</p>\n<ul>\n<li>\nCode and code comments ideally should be wrapped to a different column.\n</li>\n<li>\nFor comments, the width should be relative to the start of the comment.\n</li>\n</ul>\n<p>It\u2019s a good idea to limit line length to about 100 columns. This is a physical limit, the width at\nwhich you can still comfortably fit two editors side by side (see\n<a href=\"https://matklad.github.io/2025/11/28/size-matters.html\"><em>Size Matters</em></a>). Note an apparent\ncontradiction: the optimal width for readable prose is usually taken to be narrower, 60\u201370 columns.\nThe contradiction is resolved by noticing that, for code, indentation eats into usable space.\nTypically, code is much less typographically dense than prose.</p>\n<p>Still, I find comment blocks easier to read when they are  wrapped narrower than the surrounding\ncode. I want lines to be wrapped at 100, and <em>content</em> of comments to be wrapped at 70 (unless that\npushes overall line to be longer than 100). That is, I want layout like this (using 20/30 rulers\ninstead of 70/100, for illustrative purposes):</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-comment\">// Top level comments</span></span>\n<span class=\"line\"><span class=\"hl-comment\">// can be this wide.</span></span>\n<span class=\"line\"><span class=\"hl-keyword\">const</span> S = <span class=\"hl-keyword\">struct</span> {</span>\n<span class=\"line\">    <span class=\"hl-comment\">// Nested comments are</span></span>\n<span class=\"line\">    <span class=\"hl-comment\">// also this wide, but</span></span>\n<span class=\"line\">    <span class=\"hl-comment\">// are shifted right.</span></span>\n<span class=\"line\">    <span class=\"hl-keyword\">fn</span><span class=\"hl-function\"> f</span>() <span class=\"hl-type\">void</span> {</span>\n<span class=\"line\">        <span class=\"hl-keyword\">switch</span> (value) {</span>\n<span class=\"line\">            <span class=\"hl-numbers\">0</span> =&gt; {</span>\n<span class=\"line\">                <span class=\"hl-comment\">// But there is</span></span>\n<span class=\"line\">                <span class=\"hl-comment\">// a hard limit.</span></span>\n<span class=\"line\">            }</span>\n<span class=\"line\">        }</span>\n<span class=\"line\">    }</span>\n<span class=\"line\">}</span></code></pre>\n\n</figure>\n<p>This feels obvious in retrospect, but notably isn\u2019t be well-supported by the tools? The\n<a href=\"https://marketplace.visualstudio.com/items?itemName=stkb.rewrap\">VS Code extension</a> I use allows\nconfiguring dedicated fill column for comments, but doesn\u2019t make it <em>relative</em>, so indented comment\nblocks are always narrower than top-level ones. Emacs <code>M-q</code> also doesn\u2019t do relative wrapping out of\nthe box!</p>\n<hr />\n<p>Aside on hard-wrapping: should we bother with wrapping comments at all? Can\u2019t we rely on our editor\nto implement soft-wrapping? The problem with soft-wrapping is that you can\u2019t soft-wrap text\ncorrectly without understanding its meaning. Consider a markdown list:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">A list:</span>\n<span class=\"line\">  * item one,</span>\n<span class=\"line\">  * item two.</span></code></pre>\n\n</figure>\n<p>If the first item is long enough to necessitate wrapping, the wrapped line should also be indented,\nwhich requires parsing the text as markdown first:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">A list:</span>\n<span class=\"line\">  * item one which is long enough</span>\n<span class=\"line\">    necessitate wrapping,</span>\n<span class=\"line\">  * item two.</span></code></pre>\n\n</figure>"
            ],
            "link": "https://matklad.github.io/2026/02/21/wrapping-code-comments.html",
            "publishedAt": "2026-02-21",
            "source": "Alex Kladov",
            "summary": "<header> <h1>Wrapping Code Comments</h1> <time class=\"meta\" datetime=\"2026-02-21\">Feb 21, 2026</time> </header> <p>I was today years old when I realized that:</p> <ul> <li> Code and code comments ideally should be wrapped to a different column. </li> <li> For comments, the width should be relative to the start of the comment. </li> </ul> <p>It\u2019s a good idea to limit line length to about 100 columns. This is a physical limit, the width at which you can still comfortably fit two editors side by side (see <a href=\"https://matklad.github.io/2025/11/28/size-matters.html\"><em>Size Matters</em></a>). Note an apparent contradiction: the optimal width for readable prose is usually taken to be narrower, 60\u201370 columns. The contradiction is resolved by noticing that, for code, indentation eats into usable space. Typically, code is much less typographically dense than prose.</p> <p>Still, I find comment blocks easier to read when they are wrapped narrower than the surrounding code. I want lines to be wrapped at 100, and <em>content</em> of comments to be wrapped at 70 (unless that pushes overall line to be longer than 100). That is, I want layout like this (using 20/30 rulers instead of 70/100, for illustrative purposes):</p> <figure class=\"code-block\"> <pre><code><span class=\"line\"><span class=\"hl-comment\">// Top level comments</span></span> <span class=\"line\"><span class=\"hl-comment\">// can be this",
            "title": "Wrapping Code Comments"
        },
        {
            "content": [
                "<h3 id=\"if-code-is-free-why-arent-all-apps-native\">If code is free, why aren\u2019t all apps native?</h3>\n\n<p>The state of coding agents can be summed up by <a href=\"https://x.com/dbreunig/status/2024970389156495365?s=46\">this fact</a></p>\n\n<blockquote>\n  <p>Claude spent $20k on an agent swarm implementing (kinda) a C-compiler in Rust, but desktop Claude is an Electron app.</p>\n</blockquote>\n\n<p>If you\u2019re unfamiliar, Electron is a coding framework for building desktop applications using web tech, specifically HTML, CSS, and JS. What\u2019s great about Electron is it allows you to  build one desktop app that supports Windows, Mac, and Linux. Plus it lets developers use existing web app code to get started. It\u2019s great for teams big and small. <a href=\"https://en.wikipedia.org/wiki/List_of_software_using_Electron?wprov=sfti1\">Many apps you probably use every day are built with Electron</a>: Slack, Discord, VS Code, Teams, Notion, and more.</p>\n\n<p>There are downsides though. Electron apps are bloated; each runs its own Chromium engine. The minimum app size is usually a couple hundred megabytes. They are often laggy or unresponsive. They don\u2019t integrate well with OS features.</p>\n\n<p>(These last two issues <em>can</em> be addressed by smart development and OS-specific code, but they rarely are. The benefits of Electron (one codebase, many platforms, it\u2019s just web!) don\u2019t incentivize optimizations outside of HTML/JS/CSS land.)</p>\n\n<p>But these downsides are dramatically outweighed by the ability to build and maintain one app, shipping it everywhere.</p>\n\n<p>But now we have coding agents! <a href=\"https://www.dbreunig.com/2026/02/06/the-rise-of-spec-driven-development.html\">And one thing coding agents are proving to be pretty good at is cross-platform, cross-language implementations given a well-defined spec and test suite</a>.</p>\n\n<p>On the surface, this ability should render Electron\u2019s benefits obsolete! Rather than write one web app and ship it to each platform, we should write <em>one spec and test suite</em> and use coding agents to ship <em>native</em> code to each platform. If this ability is real and adopted, users get snappy, performant, native apps from small, focused teams serving a broad market.</p>\n\n<p>But we\u2019re still leaning on Electron. Even Anthropic, one of the leaders in AI coding tools, who keeps publishing flashy agentic coding achievements, still uses Electron in the Claude desktop app. And it\u2019s slow, buggy, and bloated app.</p>\n\n<p><em>So why are we still using Electron and not embracing the agent-powered, spec driven development future?</em></p>\n\n<p>For one thing, coding agents are <em>really</em> good at the first 90% of dev. But that last bit \u2013 nailing down all the edge cases and continuing support once it meets the real world \u2013 remains hard, tedious, and requires plenty of agent hand-holding.</p>\n\n<p>Anthropic\u2019s <a href=\"https://www.anthropic.com/engineering/building-c-compiler\">Rust-base C compiler</a> slammed into this wall, after screaming through the bulk of the tests:</p>\n\n<blockquote>\n  <p>The resulting compiler has nearly reached the limits of Opus\u2019s abilities. I tried (hard!) to fix several of the above limitations but wasn\u2019t fully successful. New features and bugfixes frequently broke existing functionality.</p>\n</blockquote>\n\n<p>The resulting compiler <em>is</em> impressive, given the time it took to deliver it and the number of people who worked on it, but it is largely unusable. That last mile is <em>hard</em>.</p>\n\n<p>And this gets even worse once a program meets the real world. Messy, unexpected scenarios stack up and development never really ends. Agents make it easier, sure, but hard product decisions become challenged and require human decisions.</p>\n\n<p>Further, with 3 different apps produced (Mac, Windows, and Linux) the surface area for bugs and support increases 3-fold. Sure, there are local quirks with Electron apps, but most of it is mitigated by the common wrapper. Not so with native!</p>\n\n<p>A good test suite and spec <em>could</em> enable the Claude team to ship a Claude desktop app native to each platform. But the resulting overhead of that last 10% of dev and the increased support and maintenance burden will remain.</p>\n\n<p>For now, Electron still makes sense. Coding agents are amazing. But the last mile of dev and the support surface area remains a real concern.</p>\n\n<hr />\n\n<form action=\"https://buttondown.com/api/emails/embed-subscribe/dbreunig\" class=\"embeddable-buttondown-form\" method=\"post\" target=\"popupwindow\">\n  <label for=\"bd-email\">Enter your email to receive the occasional update.</label>\n  <div class=\"form-input\">\n    <input id=\"bd-email\" name=\"email\" type=\"email\" />\n    <input type=\"submit\" value=\"Subscribe\" />\n  </div>\n</form>"
            ],
            "link": "https://www.dbreunig.com/2026/02/21/why-is-claude-an-electron-app.html",
            "publishedAt": "2026-02-21",
            "source": "Drew Breunig",
            "summary": "<h3 id=\"if-code-is-free-why-arent-all-apps-native\">If code is free, why aren\u2019t all apps native?</h3> <p>The state of coding agents can be summed up by <a href=\"https://x.com/dbreunig/status/2024970389156495365?s=46\">this fact</a></p> <blockquote> <p>Claude spent $20k on an agent swarm implementing (kinda) a C-compiler in Rust, but desktop Claude is an Electron app.</p> </blockquote> <p>If you\u2019re unfamiliar, Electron is a coding framework for building desktop applications using web tech, specifically HTML, CSS, and JS. What\u2019s great about Electron is it allows you to build one desktop app that supports Windows, Mac, and Linux. Plus it lets developers use existing web app code to get started. It\u2019s great for teams big and small. <a href=\"https://en.wikipedia.org/wiki/List_of_software_using_Electron?wprov=sfti1\">Many apps you probably use every day are built with Electron</a>: Slack, Discord, VS Code, Teams, Notion, and more.</p> <p>There are downsides though. Electron apps are bloated; each runs its own Chromium engine. The minimum app size is usually a couple hundred megabytes. They are often laggy or unresponsive. They don\u2019t integrate well with OS features.</p> <p>(These last two issues <em>can</em> be addressed by smart development and OS-specific code, but they rarely are. The benefits of Electron (one codebase, many platforms, it\u2019s just web!) don\u2019t incentivize optimizations outside of HTML/JS/CSS land.)</p> <p>But these downsides are dramatically",
            "title": "Why is Claude an Electron App?"
        },
        {
            "content": [],
            "link": "https://www.nytimes.com/2026/02/20/style/modern-love-ect-youre-my-wife-youre-my-life.html",
            "publishedAt": "2026-02-21",
            "source": "Modern Love - NYT",
            "summary": "When my husband collapsed in our bedroom, it was the nightmare I had long feared, coming true.",
            "title": "\u2018You\u2019re My Wife. You\u2019re My Life.\u2019"
        },
        {
            "content": [],
            "link": "https://conversationtreepress.com/pages/antimemetics-division-qntm",
            "publishedAt": "2026-02-21",
            "source": "QNTM",
            "summary": "<b><a href=\"https://qntm.org/antimemetics\">There Is No Antimemetics Division</a> \u00bb</b> There Is No Antimemetics Division will be published in a single state as a limited edition signed by the author and artist. It will be offered for sale when copies are ready to ship and feature: Offset printing on premium paper. Thoughtful interior design and typography. Newly commissioned illustrations. A durable, Smyth-sewn binding with a ribbon marker and head and tail bands. A foil stamped cloth binding similar to our Collector\u2019s Editions. A slipcase at no additional cost. ...",
            "title": "There Is No Antimemetics Division by qntm\u2013 Conversation Tree Press"
        },
        {
            "content": [],
            "link": "https://qntm.org/files/simulator/index.html",
            "publishedAt": "2026-02-21",
            "source": "QNTM",
            "summary": "<b><a href=\"https://qntm.org/src\">Code</a> \u00bb</b>\nqntm's leap second simulator\n\nDuring a leap second, Unix time cannot represent 23:59:60. So what does happen?",
            "title": "qntm's leap second simulator"
        },
        {
            "content": [],
            "link": "https://veekaybee.github.io/2026/02/21/querying-3-billion-vectors/",
            "publishedAt": "2026-02-21",
            "source": "Vicki Boykis",
            "summary": "<p>Recently, I got nerd-sniped by this exchange between <a href=\"https://github.com/LRitzdorf/TheJeffDeanFacts\">Jeff Dean</a> and someone trying to query 3 billion vectors. I was curious to see if I could implement the <a href=\"https://vickiboykis.com/2021/06/06/the-humble-hash-aggregate/\">optimal map-reduce</a> solution he alludes to in his reply.</p> <img alt=\"image\" src=\"https://gist.github.com/user-attachments/assets/ecca4afd-81bf-45a4-9043-ad7da174d93a\" width=\"400\" /> <p>A vector is a list/array of floating point numbers of <code>n</code> dimensions, where <code>n</code> is the length of the list. The reason you might perform vector search is to find words or items that are semantically similar to each other, a common pattern in search, recommendations, and generative retrieval applications <a href=\"https://read.engineerscodex.com/p/how-cursor-indexes-codebases-fast\">like Cursor</a> which heavily leverage <a href=\"https://vickiboykis.com/what_are_embeddings/\">embeddings.</a></p> <p>I started by writing an extremely naive implementation which made the following assumptions:</p> <ul> <li>we have 3 billion searchable (document) vectors and ~1k query vectors (a number I made up)</li> <li>Both of the vector sets are stored on disk in <code>.npy</code> format (simple format for <a href=\"https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html\">storing numpy arrays</a></li> <li>We&rsquo;d like to compare each of the query vectors against the larger pool of document vectors and return the resulting similarity (dot product) for each of the vector combinations.</li> <li>3k total reference vectors (to see if we could intially run this amount before scaling)</li> <li>The vectors are of dimensionality",
            "title": "Querying 3 billion vectors"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2026-02-21"
}
{
    "articles": [
        {
            "content": [
                "<p>In <a href=\"https://alexwlchan.net/2025/av1-on-my-iphone/\">my previous post</a>, I wrote about how I\u2019ve saved some AV1-encoded videos that I can\u2019t play on my iPhone.\nEventually, I\u2019ll upgrade to a new iPhone which supports AV1, but in the meantime, I want to convert all of those videos to an older codec.\nThe problem is finding all the affected videos \u2013 I don\u2019t want to wait until I want to watch a video before discovering it won\u2019t play.</p>\n\n<p>I already use <a href=\"https://docs.pytest.org/en/stable/\">pytest</a> to run some checks on my media library: are all the files in the right place, is the metadata in the correct format, do I have any <a href=\"https://alexwlchan.net/2020/using-fuzzy-string-matching-to-find-duplicate-tags/\">misspelt tags</a>, and so on.\nI wanted to write a new test that would check for AV1-encoded videos, so I could find and convert them in bulk.</p>\n\n<p>In this post, I\u2019ll show you two ways to check if a video is encoded using AV1, and a test I wrote to find any such videos inside a given folder.</p>\n\n<blockquote class=\"table_of_contents\">\n  <h3>Table of contents</h3>\n\n  <ul>\n    \n      <li>\n        <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/#getting-the-video-codec-with-ffprobe\">Getting the video codec with ffprobe</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/#getting-the-video-codec-with-mediainfo\">Getting the video codec with MediaInfo</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/#writing-a-test-to-find-videos-with-the-av1-codec\">Writing a test to find videos with the AV1 codec</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/#putting-it-all-together\">Putting it all together</a>\n\n        \n      </li>\n</ul>\n</blockquote>\n\n\n\n<h2 id=\"getting-the-video-codec-with-ffprobe\">Getting the video codec with ffprobe</h2>\n\n<p>In my last post, I wrote an <a href=\"https://ffmpeg.org/ffprobe.html\">ffprobe</a> command that prints some information about a video, including the codec.\n(ffprobe is a companion tool to the popular video converter <a href=\"https://www.ffmpeg.org/\">FFmpeg</a>.)</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">$</span><span class=\"w\"> </span>ffprobe -v error -select_streams v:0 <span class=\"p\">\\</span>\n    -show_entries stream=codec_name,profile,level,bits_per_raw_sample <span class=\"p\">\\</span>\n    -of default=noprint_wrappers=1 <span class=\"s2\">\"input.mp4\"</span>\n<span class=\"go\">codec_name=av1\nprofile=Main\nlevel=8\nbits_per_raw_sample=N/A\n</span></code></pre>\n<p>I can tweak this command to print just the codec name:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">$</span><span class=\"w\"> </span>ffprobe -v error -select_streams v:0 <span class=\"p\">\\</span>\n    -show_entries stream=codec_name <span class=\"p\">\\</span>\n    -of csv=print_section=0 <span class=\"s2\">\"input.mp4\"</span>\n<span class=\"go\">av1\n</span></code></pre>\n<p>To run this command from Python, I call the <a href=\"https://docs.python.org/3/library/subprocess.html#subprocess.check_output\"><code>check_output</code> function</a> from the <a href=\"https://docs.python.org/3/library/subprocess.html\"><code>subprocess</code> module</a>.\nThis checks the command completes successfully, then returns the output as a string.\nI can check if the output is the string <code>av1</code>:</p>\n<pre><code>import <span class=\"n\">subprocess</span>\n\n\ndef <span class=\"n\">is_av1_video</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">:</span> str<span class=\"p\">)</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if a video is encoded with AV1, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">output</span> = subprocess<span class=\"p\">.</span>check_output<span class=\"p\">([</span>\n        <span class=\"sh\">\"</span><span class=\"s\">ffprobe</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># Set the logging level\n</span>        <span class=\"sh\">\"</span><span class=\"s\">-loglevel</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">error</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># Select the first video stream\n</span>        <span class=\"sh\">\"</span><span class=\"s\">-select_streams</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">v:0</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># Print the codec_name (e.g. av1)\n</span>        <span class=\"sh\">\"</span><span class=\"s\">-show_entries</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">stream=codec_name</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># Print just the value\n</span>        <span class=\"sh\">\"</span><span class=\"s\">-output_format</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">csv=print_section=0</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># Name of the video to check\n</span>        path\n    <span class=\"p\">],</span> text=<span class=\"bp\">True</span><span class=\"p\">)</span>\n\n    return output<span class=\"p\">.</span>strip<span class=\"p\">()</span> == <span class=\"sh\">\"</span><span class=\"s\">av1</span><span class=\"sh\">\"</span>\n</code></pre>\n<p>Most of this function is defining the ffprobe command, which takes quite a few flags.\nWhenever I embed a shell command in another program, I always replace any flags/arguments with the long versions, and explain their purpose in a comment \u2013 for example, I\u2019ve replaced <code>-of</code> with <code>-output_format</code>.\nShort flags are convenient when I\u2019m typing something by hand, but long flags are more readable when I return to this code later.</p>\n\n<p>This function works, but the ffprobe command is quite long, and it requires spawning a new process for each video I want to check.\nIs there a faster way?</p>\n\n<h2 id=\"getting-the-video-codec-with-mediainfo\">Getting the video codec with MediaInfo</h2>\n\n<p>While working at the Flickr Foundation, I discovered <a href=\"https://mediaarea.net/en/MediaInfo\">MediaInfo</a>, another tool for analysing video files.\nIt\u2019s used in <a href=\"https://www.flickr.org/programs/content-mobility/data-lifeboat/\">Data Lifeboat</a> to get the <a href=\"https://alexwlchan.net/til/2025/get-video-dimensions-with-mediainfo/\">dimensions</a> and <a href=\"https://alexwlchan.net/til/2025/mediainfo-duration/\">duration</a> of videos.</p>\n\n<p>You can run MediaInfo as a command-line program to get the video codec:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">$</span><span class=\"w\"> </span>mediainfo <span class=\"nt\">--Inform</span><span class=\"o\">=</span><span class=\"s2\">\"Video;%Format%\"</span> <span class=\"s2\">\"input.mp4\"</span>\n<span class=\"go\">AV1\n</span></code></pre>\n<p>This is a simpler command than ffprobe, but I\u2019d still be spawning a new process if I called this from subprocess.</p>\n\n<p>Fortunately, MediaInfo is also available as a library, and it has <a href=\"https://github.com/sbraz/pymediainfo\">a\u00a0Python wrapper</a>.\nYou can install the wrapper with <code>pip install pymediainfo</code>, then we can use the functionality of MediaInfo inside our Python process:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span>from <span class=\"n\">pymediainfo</span> import <span class=\"n\">MediaInfo</span>\n<span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">media_info</span> = MediaInfo<span class=\"p\">.</span>parse<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">input.mp4</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n<span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span>media_info<span class=\"p\">.</span>video_tracks<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span>codec_id\n<span class=\"go\">'av01'\n</span></code></pre>\n<p>This code could throw an <code>IndexError</code> if there\u2019s no video track \u2013 if it\u2019s a <code>.mp4</code> file which only has audio data \u2013 but that\u2019s pretty unusual, and not something I\u2019ve found in any of my videos.</p>\n\n<p>I can write a new wrapper function:</p>\n<pre><code>from <span class=\"n\">pymediainfo</span> import <span class=\"n\">MediaInfo</span>\n\n\ndef <span class=\"n\">is_av1_video</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">:</span> str<span class=\"p\">)</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if a video is encoded with AV1, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">media_info</span> = MediaInfo<span class=\"p\">.</span>parse<span class=\"p\">(</span>path<span class=\"p\">)</span>\n\n    return media_info<span class=\"p\">.</span>video_tracks<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span>codec_id == <span class=\"sh\">\"</span><span class=\"s\">av01</span><span class=\"sh\">\"</span>\n</code></pre>\n<p>This is shorter than the ffprobe code, and faster too \u2013 testing locally, this is about 3.5\u00d7 faster than spawning an ffprobe process per file.</p>\n\n<h2 id=\"writing-a-test-to-find-videos-with-the-av1-codec\">Writing a test to find videos with the AV1 codec</h2>\n\n<p>Now we have a function that tells us if a given video uses AV1, we want a test that checks if there are any matching files.\nThis is what I wrote:</p>\n<pre><code>import <span class=\"n\">glob</span>\n\n\ndef <span class=\"n\">test_no_videos_are_av1</span><span class=\"p\">():</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    No videos are encoded in AV1 (which doesn</span><span class=\"sh\">'</span><span class=\"s\">t play on my iPhone).\n\n    This test can be removed when I upgrade all my devices to ones with\n    hardware AV1 decoding support.\n\n    See https://alexwlchan.net/2025/av1-on-my-iphone/\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">av1_videos</span> = <span class=\"p\">{</span>\n        <span class=\"n\">p</span>\n        for p <span class=\"ow\">in</span> glob<span class=\"p\">.</span>glob<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">**/*.mp4</span><span class=\"sh\">\"</span><span class=\"p\">,</span> recursive=<span class=\"bp\">True</span><span class=\"p\">)</span>\n        if is_av1_video<span class=\"p\">(</span>p<span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    assert av1_videos == set<span class=\"p\">()</span>\n</code></pre>\n<p>It uses the <a href=\"https://docs.python.org/3/library/glob.html#module-glob\">glob module</a> to find <code>.mp4</code> video files anywhere in the current folder, and then filters for files which use the AV1 codec.\nThe <code>recursive=True</code> argument is important, because it tells glob to search below the current directory.</p>\n\n<p>I\u2019m only looking for <code>.mp4</code> files because that\u2019s the only format I use for videos, but you might want to search for <code>.mkv</code> or <code>.webm</code> too.\nIf I was doing that, I might drop glob and use <a href=\"https://alexwlchan.net/2023/snake-walker/\">my snippet for walking a file tree</a> instead.</p>\n\n<p>The test builds a set of all the AV1 videos, then checks that it\u2019s empty.\nThis means that if the test fails, I can see all the affected videos at once.\nIf the test failed on the first AV1 video, I\u2019d only know about one video at a time, which would slow me down.</p>\n\n<h2 id=\"putting-it-all-together\">Putting it all together</h2>\n\n<p>You can use ffprobe or MediaInfo \u2013 I prefer MediaInfo because it\u2019s faster and I already have it installed, but both approaches are fine.</p>\n\n<p>Here\u2019s my final test, which uses MediaInfo to check if a video uses AV1, and scans a folder using glob.\nI\u2019ve saved it as <code>test_no_av1_videos.py</code>:</p>\n<pre><code>import <span class=\"n\">glob</span>\n\nfrom <span class=\"n\">pymediainfo</span> import <span class=\"n\">MediaInfo</span>\n\n\ndef <span class=\"n\">is_av1_video</span><span class=\"p\">(</span><span class=\"n\">path</span><span class=\"p\">:</span> str<span class=\"p\">)</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if a video is encoded with AV1, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">media_info</span> = MediaInfo<span class=\"p\">.</span>parse<span class=\"p\">(</span>path<span class=\"p\">)</span>\n\n    return media_info<span class=\"p\">.</span>video_tracks<span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span>codec_id == <span class=\"sh\">\"</span><span class=\"s\">av01</span><span class=\"sh\">\"</span>\n\n\ndef <span class=\"n\">test_no_videos_are_av1</span><span class=\"p\">():</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    No videos are encoded in AV1 (which doesn</span><span class=\"sh\">'</span><span class=\"s\">t play on my iPhone).\n\n    This test can be removed when I upgrade all my devices to ones with\n    hardware AV1 decoding support.\n\n    See https://alexwlchan.net/2025/av1-on-my-iphone/\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">av1_videos</span> = <span class=\"p\">{</span>\n        p\n        for p <span class=\"ow\">in</span> glob<span class=\"p\">.</span>glob<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">**/*.mp4</span><span class=\"sh\">\"</span><span class=\"p\">,</span> recursive=<span class=\"bp\">True</span><span class=\"p\">)</span>\n        if is_av1_video<span class=\"p\">(</span>p<span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    assert av1_videos == set<span class=\"p\">()</span>\n</code></pre>\n<p>In one folder with 350 videos, this takes about 8\u00a0seconds to run.\nI could make that faster by reading the video files in parallel, or caching the results, but it\u2019s fast enough for now.</p>\n\n<p>When I buy a new device with hardware AV1 decoding, I\u2019ll delete this test.\nUntil then, it\u2019s a quick and easy way to find and re-encode any videos that won\u2019t play on my iPhone.</p>\n\n\n    <p>[If the formatting of this post looks odd in your feed reader, <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/?ref=rss\">visit the original article</a>]</p>"
            ],
            "link": "https://alexwlchan.net/2025/detecting-av1-videos/?ref=rss",
            "publishedAt": "2025-11-08",
            "source": "Alex Chan",
            "summary": "I wrote a Python test to find videos that are encoded with AV1, so I can convert them to a codec my iPhone can play.",
            "title": "Detecting AV1-encoded videos with Python"
        },
        {
            "content": [],
            "link": "https://harper.blog/notes/2025-11-08_a45838b2a0bb_aphyr-com-posts-397-read-this-/",
            "publishedAt": "2025-11-08",
            "source": "Harper Reed",
            "summary": "<p><a href=\"https://aphyr.com/posts/397-i-want-you-to-understand-chicago\">aphyr.com/posts/397\u2026</a></p>\n<p>Read this about Chicago</p>\n\n                        \n                        <hr />\n                        <p>Thank you for using RSS. I appreciate you. <a href=\"mailto:harper&#64;modest.com\">Email me</a></p>",
            "title": "Note #295"
        },
        {
            "content": [],
            "link": "https://harper.blog/notes/2025-11-07_dd5c7f70a270_working-winter-afternoon-light/",
            "publishedAt": "2025-11-08",
            "source": "Harper Reed",
            "summary": "<p>Working winter afternoon light.</p> <figure> <img alt=\"image_1.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-11-07_dd5c7f70a270_working-winter-afternoon-light/image_1.jpg\" width=\"1800\" /> </figure> <figure> <img alt=\"image_2.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-11-07_dd5c7f70a270_working-winter-afternoon-light/image_2.jpg\" width=\"1800\" /> </figure> <figure> <img alt=\"image_3.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-11-07_dd5c7f70a270_working-winter-afternoon-light/image_3.jpg\" width=\"1800\" /> </figure> <figure> <img alt=\"image_4.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-11-07_dd5c7f70a270_working-winter-afternoon-light/image_4.jpg\" width=\"1800\" /> </figure> <hr /> <p>Thank you for using RSS. I appreciate you. <a href=\"mailto:harper&#64;modest.com\">Email me</a></p>",
            "title": "Note #294"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2025-11-08"
}
{
    "articles": [
        {
            "content": [
                "<header>\n  <h1>Parsing Advances</h1>\n  <time class=\"meta\" datetime=\"2025-12-28\">Dec 28, 2025</time>\n</header>\n<p>I find myself writing yet another toy parser, as one does during a Christmas break. It roughly follows\n<a href=\"https://matklad.github.io/2023/05/21/resilient-ll-parsing-tutorial.html\"><em>Resilient LL Parsing Tutorial</em></a>.\nNot because I need resilience, but mostly because I find producing a syntax tree and a collection of\ndiagnostics a more natural fit for the problem than bailing out on the first error.</p>\n<p>One practical pitfall with the approach is infinite loops/recursion. Resilience sometimes means\n<em>not</em> consuming a token, and, if you do that in a loop or a Pratt recursive call, you\u2019ll get\nyourself an annoying to debug error:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">running 1 test from ./src/corpus_test.ts</span>\n<span class=\"line\">corpus ...Task test deno test --allow-read=./src/corpus --allow-write=./src/corpus &quot;--&quot; &quot;--update&quot;</span>\n<span class=\"line\">Check src/corpus_test.ts</span>\n<span class=\"line\"></span>\n<span class=\"line\">&lt;--- Last few GCs ---&gt;</span>\n<span class=\"line\">4,[26641:0x9d1574000]     7390 ms: Mark-Compact (reduce) 3924.9 (3927.3) -&gt; 3924.9 (3926.3) MB, pooled: 0.0 MB, 1224.00 / 0.00 ms (+ 0.3 ms in 1 steps since start of marking, biggest step 0.3 ms, walltime since start of marking 1232 ms) (average mu = 0.200,[26641:0x9d1574000]     8804 ms: Mark-Compact (reduce) 4009.9 (4011.3) -&gt; 4009.9 (4011.3) MB, pooled: 0.0 MB, 1294.67 / 0.00 ms (+ 0.2 ms in 1 steps since start of marking, biggest step 0.2 ms, walltime since start of marking 1302 ms) (average mu = 0.141,</span>\n<span class=\"line\"></span>\n<span class=\"line\"></span>\n<span class=\"line\">#</span>\n<span class=\"line\"># Fatal JavaScript out of memory: Ineffective mark-compacts near heap limit</span>\n<span class=\"line\">#</span>\n<span class=\"line\">==== C stack trace ===============================</span>\n<span class=\"line\"></span>\n<span class=\"line\">    0   deno                                0x0000000102ce8404 v8::base::debug::StackTrace::StackTrace() + 24</span>\n<span class=\"line\">    1   deno                                0x0000000102ceeb9c v8::platform::(anonymous namespace)::PrintStackTrace() + 24</span>\n<span class=\"line\">    2   deno                                0x0000000102ce4094 v8::base::FatalOOM(v8::base::OOMType, char const*) + 68</span>\n<span class=\"line\">    3   deno                                0x0000000102d3a7a8 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*, char const*, v8::OOMDetails const&amp;) + 296</span>\n<span class=\"line\">    4   deno                                0x0000000102f37378 v8::internal::Heap::stack() + 0</span>\n<span class=\"line\">    5   deno                                0x0000000102f3581c v8::internal::Heap::CheckMemoryPressure() + 0</span>\n<span class=\"line\">    6   deno                                0x0000000102ead4f8 v8::internal::StackGuard::HandleInterrupts(v8::internal::StackGuard::InterruptLevel) + 504</span>\n<span class=\"line\">    7   deno                                0x000000010335fe44 v8::internal::Runtime_HandleNoHeapWritesInterrupts(int, unsigned long*, v8::internal::Isolate*) + 304</span>\n<span class=\"line\">    8   deno                                0x00000001043887b4 Builtins_CEntry_Return1_ArgvOnStack_NoBuiltinExit + 84</span>\n<span class=\"line\">    9   ???                                 0x0000000126997874 0x0 + 4942559348</span>\n<span class=\"line\">    10  ???                                 0x000000012698a758 0x0 + 4942505816</span>\n<span class=\"line\">...</span></code></pre>\n\n</figure>\n<p>For a concrete example, you might parse function argument list using code like this:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">const</span> <span class=\"hl-attr\">result</span>: ast.<span class=\"hl-property\">Expression</span>[] = [];</span>\n<span class=\"line\">p.<span class=\"hl-title function_\">expect</span>(<span class=\"hl-params\"><span class=\"hl-string\">&quot;(&quot;</span></span>);</span>\n<span class=\"line\"><span class=\"hl-keyword\">while</span> (!p.<span class=\"hl-title function_\">eof</span>() &amp;&amp; !p.<span class=\"hl-title function_\">at</span>(<span class=\"hl-string\">&quot;)&quot;</span>)) {</span>\n<span class=\"line\">  result.<span class=\"hl-title function_\">push</span>(<span class=\"hl-title function_\">expression</span>(p));</span>\n<span class=\"line\">  <span class=\"hl-keyword\">if</span> (!p.<span class=\"hl-title function_\">at</span>(<span class=\"hl-string\">&quot;)&quot;</span>)) p.<span class=\"hl-title function_\">expect</span>(<span class=\"hl-string\">&quot;,&quot;</span>);</span>\n<span class=\"line\">}</span>\n<span class=\"line\">p.<span class=\"hl-title function_\">expect</span>(<span class=\"hl-string\">&quot;)&quot;</span>);</span>\n<span class=\"line\"><span class=\"hl-keyword\">return</span> result;</span></code></pre>\n\n</figure>\n<p>The implicit contract here is that <code>expression</code> consumes at least one token, even if there are\nerrors in the source code. If there\u2019s some token that makes <code>expression</code> bail without consuming\nanything, the code loops forever, and you\u2019ll need a debugger to get at the stack trace!</p>\n<p>The way I solved this issue traditionally is via a combination of two techniques:</p>\n<p><em>Fuel:</em> parser has a <code>fuel: Cell&lt;u32&gt;</code> field, which is decremented even by \u201creadonly\u201d lookahead\nmethods, and topped up every time the parser consumes a token. Fuel is useful to make you parser\ncrash somewhat cleanly, though the crash is typically still removed from problematic function by\nseveral stack frames.</p>\n<p>The second technique is to maintain a mental map of functions which always consume at least one\ntoken of input, and functions which might bail without consuming anything. And, whenever you write a\nloop or a recursive call, consult this map to be sure to call at least one token-consuming function.\nHard and error prone!</p>\n<p>Well, I think I\u2019ve figured something better today! You can assert that parser did advance when you\nexpect it to. The <em>smaller</em> benefit here is that if parser didn\u2019t advance, you get an immediate\nerror. The <em>bigger</em> benefit is that these asserts materialize the mental map of advancing functions\nin the source code, so it doesn\u2019t have to be mental anymore!</p>\n<p>This seems like an obvious idea in retrospect, but, well, took me more than one parser to figure it\nout!</p>\n<p>Concretely, I came up with the following base parser API:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">class</span> <span class=\"hl-title class_\">Parser</span> {</span>\n<span class=\"line\">  <span class=\"hl-keyword\">private</span> <span class=\"hl-attr\">tokens</span>: ast.<span class=\"hl-property\">Token</span>[];</span>\n<span class=\"line\">  <span class=\"hl-keyword\">private</span> <span class=\"hl-attr\">index</span>: <span class=\"hl-built_in\">number</span> = <span class=\"hl-number\">0</span>;</span>\n<span class=\"line\">  <span class=\"hl-keyword\">private</span> <span class=\"hl-attr\">advances</span>: <span class=\"hl-built_in\">number</span>[] = [];</span>\n<span class=\"line\"></span>\n<span class=\"line\">  <span class=\"hl-title function_\">advance_push</span>(<span class=\"hl-params\"></span>) {</span>\n<span class=\"line\">    <span class=\"hl-variable language_\">this</span>.<span class=\"hl-property\">advances</span>.<span class=\"hl-title function_\">push</span>(<span class=\"hl-variable language_\">this</span>.<span class=\"hl-property\">index</span>);</span>\n<span class=\"line\">  }</span>\n<span class=\"line\">  <span class=\"hl-title function_\">advance_pop</span>(<span class=\"hl-params\"></span>) {</span>\n<span class=\"line\">    <span class=\"hl-keyword\">const</span> advance = <span class=\"hl-variable language_\">this</span>.<span class=\"hl-property\">advances</span>.<span class=\"hl-title function_\">pop</span>();</span>\n<span class=\"line\">    <span class=\"hl-title function_\">assert</span>(advance !== <span class=\"hl-literal\">undefined</span>);</span>\n<span class=\"line\">    <span class=\"hl-title function_\">assert</span>(advance &lt; <span class=\"hl-variable language_\">this</span>.<span class=\"hl-property\">index</span>);</span>\n<span class=\"line\">  }</span>\n<span class=\"line\">  <span class=\"hl-title function_\">advance_drop</span>(<span class=\"hl-params\"></span>) {</span>\n<span class=\"line\">    <span class=\"hl-keyword\">const</span> advance = <span class=\"hl-variable language_\">this</span>.<span class=\"hl-property\">advances</span>.<span class=\"hl-title function_\">pop</span>();</span>\n<span class=\"line\">    <span class=\"hl-title function_\">assert</span>(advance !== <span class=\"hl-literal\">undefined</span>);</span>\n<span class=\"line\">  }</span>\n<span class=\"line\">}</span></code></pre>\n\n</figure>\n<p>And here is the buggy function that lead to the error at the start of the article:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">function</span> <span class=\"hl-title function_\">expression_pratt</span>(<span class=\"hl-params\"></span></span>\n<span class=\"line\"><span class=\"hl-params\">  p: Parser,</span></span>\n<span class=\"line\"><span class=\"hl-params\">  left: ast.TokenTag,</span></span>\n<span class=\"line\"><span class=\"hl-params\"></span>): ast.<span class=\"hl-property\">Expression</span> {</span>\n<span class=\"line\">  <span class=\"hl-keyword\">let</span> <span class=\"hl-attr\">lhs</span>: ast.<span class=\"hl-property\">Expression</span> = <span class=\"hl-title function_\">expression_delimited</span>(p);</span>\n<span class=\"line\"></span>\n<span class=\"line\">  <span class=\"hl-keyword\">while</span> (p.<span class=\"hl-title function_\">at</span>(<span class=\"hl-params\"><span class=\"hl-string\">&quot;(&quot;</span></span>)) {</span>\n<span class=\"line\">    lhs = <span class=\"hl-title function_\">expression_call</span>(p, lhs);</span>\n<span class=\"line\">  }</span>\n<span class=\"line\"></span>\n<span class=\"line\">  <span class=\"hl-keyword\">while</span> (<span class=\"hl-literal\">true</span>) {</span>\n<span class=\"line\">    <span class=\"hl-keyword\">const</span> right = p.<span class=\"hl-title function_\">token</span>();</span>\n<span class=\"line\">    <span class=\"hl-keyword\">if</span> (<span class=\"hl-title function_\">expression_pratt_right_binds_tighter</span>(left, right.<span class=\"hl-property\">tag</span>)) {</span>\n<span class=\"line\">      <span class=\"hl-keyword\">const</span> rhs = <span class=\"hl-title function_\">expression_pratt</span>(p, right.<span class=\"hl-property\">tag</span>);</span>\n<span class=\"line\">      lhs = {</span>\n<span class=\"line\">        <span class=\"hl-attr\">tag</span>: <span class=\"hl-string\">&quot;ExpressionBinary&quot;</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">location</span>: right.<span class=\"hl-property\">location</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">operator</span>: right.<span class=\"hl-property\">tag</span> <span class=\"hl-keyword\">as</span> ast.<span class=\"hl-property\">BinaryOperation</span>,</span>\n<span class=\"line\">        lhs,</span>\n<span class=\"line\">        rhs,</span>\n<span class=\"line\">      };</span>\n<span class=\"line\">    } <span class=\"hl-keyword\">else</span> {</span>\n<span class=\"line\">      <span class=\"hl-keyword\">return</span> lhs;</span>\n<span class=\"line\">    }</span>\n<span class=\"line\">  }</span>\n<span class=\"line\">}</span></code></pre>\n\n</figure>\n<p>The same function, but with advanced assertions:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">function</span> <span class=\"hl-title function_\">expression_pratt</span>(<span class=\"hl-params\"></span></span>\n<span class=\"line\"><span class=\"hl-params\">  p: Parser,</span></span>\n<span class=\"line\"><span class=\"hl-params\">  left: ast.TokenTag,</span></span>\n<span class=\"line\"><span class=\"hl-params\"></span>): ast.<span class=\"hl-property\">Expression</span> {</span>\n<span class=\"line\">  <span class=\"hl-keyword\">let</span> <span class=\"hl-attr\">lhs</span>: ast.<span class=\"hl-property\">Expression</span> = <span class=\"hl-title function_\">expression_delimited</span>(p);</span>\n<span class=\"line\"></span>\n<span class=\"line\">  <span class=\"hl-keyword\">while</span> (p.<span class=\"hl-title function_\">at</span>(<span class=\"hl-params\"><span class=\"hl-string\">&quot;(&quot;</span></span>)) {</span>\n<span class=\"line\">    lhs = <span class=\"hl-title function_\">expression_call</span>(p, lhs);</span>\n<span class=\"line\">  }</span>\n<span class=\"line\"></span>\n<span class=\"line\">  <span class=\"hl-keyword\">while</span> (<span class=\"hl-literal\">true</span>) {</span>\n<span class=\"line hl-line\">    p.<span class=\"hl-title function_\">advance_push</span>();</span>\n<span class=\"line\">    <span class=\"hl-keyword\">const</span> right = p.<span class=\"hl-title function_\">token</span>();</span>\n<span class=\"line\">    <span class=\"hl-keyword\">if</span> (<span class=\"hl-title function_\">expression_pratt_right_binds_tighter</span>(left, right.<span class=\"hl-property\">tag</span>)) {</span>\n<span class=\"line\">      <span class=\"hl-keyword\">const</span> rhs = <span class=\"hl-title function_\">expression_pratt</span>(p, right.<span class=\"hl-property\">tag</span>);</span>\n<span class=\"line\">      lhs = {</span>\n<span class=\"line\">        <span class=\"hl-attr\">tag</span>: <span class=\"hl-string\">&quot;ExpressionBinary&quot;</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">location</span>: right.<span class=\"hl-property\">location</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">operator</span>: rhs.<span class=\"hl-property\">tag</span> <span class=\"hl-keyword\">as</span> ast.<span class=\"hl-property\">BinaryOperation</span>,</span>\n<span class=\"line\">        lhs,</span>\n<span class=\"line\">        rhs,</span>\n<span class=\"line\">      };</span>\n<span class=\"line\">    } <span class=\"hl-keyword\">else</span> {</span>\n<span class=\"line hl-line\">      p.<span class=\"hl-title function_\">advance_drop</span>();</span>\n<span class=\"line\">      <span class=\"hl-keyword\">return</span> lhs;</span>\n<span class=\"line\">    }</span>\n<span class=\"line hl-line\">    p.<span class=\"hl-title function_\">advance_pop</span>();</span>\n<span class=\"line\">  }</span>\n<span class=\"line\">}</span></code></pre>\n\n</figure>\n<p>The new error message:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">running 1 test from ./src/corpus_test.ts</span>\n<span class=\"line\">corpus ... FAILED (11ms)</span>\n<span class=\"line\"></span>\n<span class=\"line\"> ERRORS</span>\n<span class=\"line\"></span>\n<span class=\"line\">corpus =&gt; ./src/corpus_test.ts:47:6</span>\n<span class=\"line\">error: Error: assertion failed</span>\n<span class=\"line\">  if (!condition) throw new Error(&quot;assertion failed&quot;);</span>\n<span class=\"line\">                        ^</span>\n<span class=\"line\">    at assert (./src/stdx.ts:2:25)</span>\n<span class=\"line\">    at Parser.advance_pop (./src/parse.ts:132:5)</span>\n<span class=\"line\">    at expression_pratt (./src/parse_grammar.ts:169:7)</span>\n<span class=\"line\">    at expression (./src/parse_grammar.ts:143:10)</span>\n<span class=\"line\">    at expression_block (./src/parse_grammar.ts:305:21)</span>\n<span class=\"line\">    at declaration_fun (./src/parse_grammar.ts:73:7)</span>\n<span class=\"line\">    at declaration (./src/parse_grammar.ts:25:12)</span>\n<span class=\"line\">    at Module.file (./src/parse_grammar.ts:10:15)</span>\n<span class=\"line\">    at Module.parse (./src/parse.ts:13:18)</span>\n<span class=\"line\">    at ast_dump (./src/corpus_test.ts:85:22)</span></code></pre>\n\n</figure>\n<p>and the fix:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\">  <span class=\"hl-keyword\">while</span> (<span class=\"hl-literal\">true</span>) {</span>\n<span class=\"line\">    p.<span class=\"hl-title function_\">advance_push</span>();</span>\n<span class=\"line\">    <span class=\"hl-keyword\">const</span> right = p.<span class=\"hl-title function_\">token</span>();</span>\n<span class=\"line\">    <span class=\"hl-keyword\">if</span> (<span class=\"hl-title function_\">expression_pratt_right_binds_tighter</span>(left, right.<span class=\"hl-property\">tag</span>)) {</span>\n<span class=\"line hl-line\">      p.<span class=\"hl-title function_\">bump</span>();</span>\n<span class=\"line\">      <span class=\"hl-keyword\">const</span> rhs = <span class=\"hl-title function_\">expression_pratt</span>(p, right.<span class=\"hl-property\">tag</span>);</span>\n<span class=\"line\">      lhs = {</span>\n<span class=\"line\">        <span class=\"hl-attr\">tag</span>: <span class=\"hl-string\">&quot;ExpressionBinary&quot;</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">location</span>: right.<span class=\"hl-property\">location</span>,</span>\n<span class=\"line\">        <span class=\"hl-attr\">operator</span>: rhs.<span class=\"hl-property\">tag</span> <span class=\"hl-keyword\">as</span> ast.<span class=\"hl-property\">BinaryOperation</span>,</span>\n<span class=\"line\">        lhs,</span>\n<span class=\"line\">        rhs,</span>\n<span class=\"line\">      };</span>\n<span class=\"line\">    } <span class=\"hl-keyword\">else</span> {</span>\n<span class=\"line\">      p.<span class=\"hl-title function_\">advance_drop</span>();</span>\n<span class=\"line\">      <span class=\"hl-keyword\">return</span> lhs;</span>\n<span class=\"line\">    }</span>\n<span class=\"line\">    p.<span class=\"hl-title function_\">advance_pop</span>();</span>\n<span class=\"line\">  }</span></code></pre>\n\n</figure>"
            ],
            "link": "https://matklad.github.io/2025/12/28/parsing-advances.html",
            "publishedAt": "2025-12-28",
            "source": "Alex Kladov",
            "summary": "I find myself writing yet another toy parser, as one does during a Christmas break. It roughly follows Resilient LL Parsing Tutorial. Not because I need resilience, but mostly because I find producing a syntax tree and a collection of diagnostics a more natural fit for the problem than bailing out on the first error.",
            "title": "Parsing Advances"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2025-12-28"
}
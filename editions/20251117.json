{
    "articles": [
        {
            "content": [
                "<p>I\u2019ve been cleaning up some messy data, and it includes timestamps written by a variety of humans and machines, which don\u2019t use a consistent format.</p>\n\n<p>Here are a few examples:</p>\n<pre><code>2025-10-14T05:34:07+0000\n2015-03-01 23:34:39 +00:00\n2013-9-21 13:43:00Z\n2024-08-30\n</code></pre>\n<p>All of these timestamps are machine-readable, but it would be easier for the downstream code if there weren\u2019t as many different formats.\nFor example, the downstream code uses the JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date\"><code>Date()</code> constructor</a>, which rejects some of the timestamps as invalid.</p>\n\n<p>I wrote a Python script to help me find, validate, and normalise all my timestamps, so the rest of my code can deal with a more consistent set.</p>\n\n<blockquote class=\"table_of_contents\">\n  <h3>Table of contents</h3>\n\n  <ul>\n    \n      <li>\n        <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#finding-all-the-data-strings\">Finding all the data strings</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#checking-if-a-date-string-matches-a-given-format\">Checking if a date string matches a given format</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#testing-that-all-of-my-timestamps-use-consistent-formats\">Testing that all of my timestamps use consistent formats</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#changing-the-format-of-date-strings-in-bulk\">Changing the format of date strings in bulk</a>\n\n        \n      </li>\n      <li>\n        <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#putting-it-all-together\">Putting it all together</a>\n\n        \n      </li>\n</ul>\n</blockquote>\n\n\n\n<h2 id=\"finding-all-the-data-strings\">Finding all the data strings</h2>\n\n<p>All the messy data is in JSON, and the structure is quite inconsistent \u2013 a lot of heavily nested objects, differently-named fields, varying models and schemas.\nThis project is about tidying it up.</p>\n\n<p>One saving gracing is that the timestamps are named fairly consistently \u2013 they\u2019re all stored inside JSON objects, with keys that start with <code>date_</code>, and values which are strings.\nHere\u2019s an example:</p>\n<pre><code><span class=\"p\">{</span><span class=\"w\">\n  </span><span class=\"nl\">\"doc1\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"nl\">\"id\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"1\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nl\">\"date_created\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2025-10-14T05:34:07+0000\"</span><span class=\"p\">},</span><span class=\"w\">\n  </span><span class=\"nl\">\"shapes\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"p\">[</span><span class=\"w\">\n  \t</span><span class=\"p\">{</span><span class=\"nl\">\"color\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"blue\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nl\">\"date_saved\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2015-03-01 23:34:39 +00:00\"</span><span class=\"p\">},</span><span class=\"w\">\n  \t</span><span class=\"p\">{</span><span class=\"nl\">\"color\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"yellow\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nl\">\"date_saved\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2013-9-21 13:43:00Z\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nl\">\"is_square\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">true</span><span class=\"p\">},</span><span class=\"w\">\n  \t</span><span class=\"p\">{</span><span class=\"nl\">\"color\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"green\"</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"nl\">\"date_saved\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"kc\">null</span><span class=\"p\">}</span><span class=\"w\">\n  </span><span class=\"p\">],</span><span class=\"w\">\n  </span><span class=\"nl\">\"date_verified\"</span><span class=\"p\">:</span><span class=\"w\"> </span><span class=\"s2\">\"2024-08-30\"</span><span class=\"w\">\n</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre>\n<p>The first thing I want to do is find all the key-value pairs which combine a <code>date_</code> and a string.</p>\n\n<p>I wrote a Python function to recursively walk the JSON and pull out matching pairs.\nI\u2019m sure there are libraries for this, but JSON is simple enough that I can write it by hand.\nIt only has a few types, and even fewer that matter here:</p>\n\n<ul>\n  <li>If it\u2019s a JSON object: inspect its keys, then recurse into each value</li>\n  <li>If it\u2019s a JSON array: recurse into each element</li>\n  <li>If it\u2019s a string, number, bool, or null: ignore it</li>\n</ul>\n\n<p>Here\u2019s my code:</p>\n<pre><code>from <span class=\"n\">collections</span><span class=\"p\">.</span><span class=\"n\">abc</span> import <span class=\"n\">Iterator</span>\nfrom <span class=\"n\">typing</span> import <span class=\"n\">Any</span>\n\n\ndef <span class=\"n\">find_all_dates</span><span class=\"p\">(</span><span class=\"n\">json_value</span><span class=\"p\">:</span> Any<span class=\"p\">)</span> -&gt; Iterator<span class=\"p\">[</span>tuple<span class=\"p\">[</span>dict<span class=\"p\">[</span>str<span class=\"p\">,</span> Any<span class=\"p\">],</span> str<span class=\"p\">,</span> str<span class=\"p\">]]:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Find all the timestamps in a heavily nested JSON object.\n\n    This function looks for any JSON objects with a key-value pair\n    where the key starts with `date_` and the value is a string, and\n    emits a 3-tuple:\n\n    *   the JSON object\n    *   the key\n    *   the value\n\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"c1\"># Case 1: JSON objects\n</span>    if isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> dict<span class=\"p\">):</span>\n        for <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> json_value<span class=\"p\">.</span>items<span class=\"p\">():</span>\n            if <span class=\"p\">(</span>\n                isinstance<span class=\"p\">(</span>key<span class=\"p\">,</span> str<span class=\"p\">)</span>\n                <span class=\"ow\">and</span> key<span class=\"p\">.</span>startswith<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">date_</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n                <span class=\"ow\">and</span> isinstance<span class=\"p\">(</span>value<span class=\"p\">,</span> str<span class=\"p\">)</span>\n            <span class=\"p\">):</span>\n                yield json_value<span class=\"p\">,</span> key<span class=\"p\">,</span> value\n            else<span class=\"p\">:</span>\n                yield from find_all_dates<span class=\"p\">(</span>value<span class=\"p\">)</span>\n\n    <span class=\"c1\"># Case 2: JSON arrays\n</span>    elif isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> list<span class=\"p\">):</span>\n        for <span class=\"n\">value</span> <span class=\"ow\">in</span> json_value<span class=\"p\">:</span>\n            yield from find_all_dates<span class=\"p\">(</span>value<span class=\"p\">)</span>\n\n    <span class=\"c1\"># Case 3: other JSON types\n</span>    elif isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> <span class=\"p\">(</span>str<span class=\"p\">,</span> int<span class=\"p\">,</span> bool<span class=\"p\">))</span> <span class=\"ow\">or</span> json_value <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        return\n\n    <span class=\"c1\"># Case 4: handle unexpected types\n</span>    else<span class=\"p\">:</span>\n        raise TypeError<span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"sh\">\"</span><span class=\"s\">Unexpected type: </span><span class=\"si\">{</span>type<span class=\"p\">(</span>json_value<span class=\"p\">)</span><span class=\"si\">}</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n</code></pre>\n<p>There are branches for all the builtin JSON types, then a catch-all branch for anything else.</p>\n\n<p>I added a catch-all <code>TypeError</code> branch to catch list- or dict-like inputs that aren\u2019t actually JSON types \u2013 things like <code>dict.values()</code> or custom container classes.\nWithout this check, they\u2019d fall through to the \u201cignore\u201d case and quietly drop nested data.\nAn explicit error makes the failure obvious, and the fix is easy: wrap the input in <code>list()</code> or <code>dict()</code>.</p>\n\n<p>For each timestamp it finds, the function emits a tuple with the nested object, the key and the value.\nFor the example above, here\u2019s the first tuple it returns:</p>\n<pre><code><span class=\"p\">({</span><span class=\"sh\">\"</span><span class=\"s\">id</span><span class=\"sh\">\"</span><span class=\"p\">:</span> <span class=\"sh\">\"</span><span class=\"s\">1</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">date_created</span><span class=\"sh\">\"</span><span class=\"p\">:</span> <span class=\"sh\">\"</span><span class=\"s\">2025-10-14T05:34:07+0000</span><span class=\"sh\">\"</span><span class=\"p\">},</span>\n <span class=\"sh\">\"</span><span class=\"s\">date_created</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n <span class=\"sh\">\"</span><span class=\"s\">2025-10-14T05:34:07+0000</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n</code></pre>\n<p>This return type allows me to both read and modify the JSON with the same function:</p>\n<pre><code><span class=\"c1\"># Reading the timestamps\n</span>for _<span class=\"p\">,</span> _<span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span><span class=\"n\">json_value</span><span class=\"p\">):</span>\n    print<span class=\"p\">(</span>date_string<span class=\"p\">)</span>\n\n<span class=\"c1\"># Modifying the timestamps\n</span>for <span class=\"n\">json_obj</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span><span class=\"n\">json_value</span><span class=\"p\">):</span>\n    json_obj<span class=\"p\">[</span>key<span class=\"p\">]</span> = run_fixup<span class=\"p\">(</span>date_string<span class=\"p\">)</span>\n</code></pre>\n<p>The latter works because <code>json_obj</code> points to the actual dictionary from the nested JSON, not a copy, so when we assign <code>json_obj[key] = \u2026</code>, we modify the original JSON structure in-place.</p>\n\n<p>Now we can find all the timestamps, we need to check if they use a consistent datetime format.</p>\n\n<h2 id=\"checking-if-a-date-string-matches-a-given-format\">Checking if a date string matches a given format</h2>\n\n<p>I normally parse timestamps in Python with the <a href=\"https://docs.python.org/3/library/datetime.html#datetime.datetime.strptime\"><code>datetime.strptime</code> function</a>.\nThis is quite a strict function, because you have to pass it a <a href=\"https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes\">format string</a> that describes exactly how you expect the timestamp to be formatted.</p>\n\n<p>If you want a more flexible approach, you can use the <a href=\"https://dateutil.readthedocs.io/en/stable/index.html\"><code>python-dateutil</code> module</a>, which has a <a href=\"https://dateutil.readthedocs.io/en/stable/parser.html\">generic parser</a> that guesses how to read the timestamp, rather than asking you to specify.</p>\n\n<p>I prefer strict parsing, because I (usually!) know exactly how timestamps will be formatted, and inconsistent formats can hide bugs.\nThere\u2019s no room for ambiguity, and no risk of a timestamp being guessed incorrectly.</p>\n\n<p>The <code>strptime</code> function takes two arguments: the string you want to parse, and the format string.\nHere\u2019s an example:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span>from <span class=\"n\">datetime</span> import <span class=\"n\">datetime</span>\n<span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span>datetime<span class=\"p\">.</span>strptime<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">2001-02-03T04:05:06+00:00</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n<span class=\"go\">datetime.datetime(2001, 2, 3, 4, 5, 6, tzinfo=datetime.timezone.utc)\n</span></code></pre>\n<p>If you pass a timestamp that doesn\u2019t match the format string, it throws a ValueError:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">datetime</span><span class=\"p\">.</span><span class=\"nf\">strptime</span><span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">2001-02-03</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n<span class=\"go\">ValueError: time data '2001-02-03' does not match format '%Y-%m-%dT%H:%M:%S%z'\n</span></code></pre>\n<p>It also checks that the whole string is parsed, and throws a ValueError if it\u2019s an incomplete match:</p>\n\n<pre class=\"language-console\"><code><span class=\"gp\">&gt;&gt;&gt;</span><span class=\"w\"> </span><span class=\"n\">datetime</span><span class=\"p\">.</span><span class=\"nf\">strptime</span><span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">2001-02-03T04:05:06+00:00</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%d</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n<span class=\"go\">ValueError: unconverted data remains: T04:05:06+00:00\n</span></code></pre>\n<p>This allows us to write a function that checks if a timestamp matches a given format:</p>\n<pre><code>from <span class=\"n\">datetime</span> import <span class=\"n\">datetime</span>\n\n\ndef <span class=\"n\">date_matches_format</span><span class=\"p\">(</span><span class=\"n\">date_string</span><span class=\"p\">:</span> str<span class=\"p\">,</span> <span class=\"n\">format</span><span class=\"p\">:</span> str<span class=\"p\">)</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if `date_string` can be parsed as a datetime\n    using `format`, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    try<span class=\"p\">:</span>\n        datetime<span class=\"p\">.</span>strptime<span class=\"p\">(</span>date_string<span class=\"p\">,</span> format<span class=\"p\">)</span>\n        return <span class=\"bp\">True</span>\n    except ValueError<span class=\"p\">:</span>\n        return <span class=\"bp\">False</span>\n</code></pre>\n<p>The <code>format</code> can be any format code supported by <code>strptime()</code>.\nThe <a href=\"https://docs.python.org/3/library/datetime.html#strftime-strptime-behavior\">Python docs</a> have a list of all the accepted format codes.\nThat list includes a couple of non-standard format codes which only have partial support, which is part of why I want to clean up these date strings.</p>\n\n<p>If we want to allow multiple formats, we can wrap this function <a href=\"https://docs.python.org/3/library/functions.html#any\">using <code>any()</code></a>:</p>\n<pre><code>def <span class=\"n\">date_matches_any_format</span><span class=\"p\">(</span><span class=\"n\">date_string</span><span class=\"p\">:</span> str<span class=\"p\">,</span> <span class=\"n\">formats</span><span class=\"p\">:</span> tuple<span class=\"p\">[</span>str<span class=\"p\">])</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if `date_string` can be parsed as a datetime\n    with any of the `formats`, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    return any<span class=\"p\">(</span>\n        date_matches_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> fmt<span class=\"p\">)</span>\n        for fmt <span class=\"ow\">in</span> formats\n    <span class=\"p\">)</span>\n</code></pre>\n<p>Here\u2019s how we can use this function to find any timestamps that don\u2019t match our allowed formats:</p>\n<pre><code><span class=\"n\">allowed_formats</span> = <span class=\"p\">(</span>\n    <span class=\"c1\"># 2001-02-03T04:05:06+07:00\n</span>    <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n    <span class=\"c1\">#\n</span>    <span class=\"c1\"># 2001-02-03\n</span>    <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%d</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n<span class=\"p\">)</span>\n\nfor _<span class=\"p\">,</span> _<span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span>json_value<span class=\"p\">):</span>\n    if <span class=\"ow\">not</span> date_matches_any_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> allowed_formats<span class=\"p\">):</span>\n        print<span class=\"p\">(</span>date_string<span class=\"p\">)</span>\n</code></pre>\n<h2 id=\"testing-that-all-of-my-timestamps-use-consistent-formats\">Testing that all of my timestamps use consistent formats</h2>\n\n<p>With these two functions in hand, I wrote a test I can run with pytest to tell me about any timestamps that don\u2019t match my allowed formats:</p>\n<pre><code>def <span class=\"n\">test_all_timestamps_are_consistent</span><span class=\"p\">():</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    All the timestamps in my JSON use a consistent format.\n\n    See https://alexwlchan.net/2025/messy-dates-in-json/\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"n\">allowed_formats</span> = <span class=\"p\">(</span>\n        <span class=\"c1\"># 2001-02-03T04:05:06+07:00\n</span>        <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># 2001-02-03\n</span>        <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%d</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"n\">bad_date_strings</span> = <span class=\"p\">{</span>\n        date_string\n        for _<span class=\"p\">,</span> _<span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span><span class=\"n\">JSON_DATA</span><span class=\"p\">)</span>\n        if <span class=\"ow\">not</span> date_matches_any_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> allowed_formats<span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    assert bad_date_strings == set<span class=\"p\">()</span>\n</code></pre>\n<p>If you only allow a single format, you could simplify this slightly by using <code>date_matches_format</code>.</p>\n\n<p>If the test passes, all your timestamps match the allowed formats.\nIf the test fails, pytest prints the ones that don\u2019t.\nRunning it on our original example shows two disallowed timestamps:</p>\n<pre><code>AssertionError: assert {'2013-9-21 1...34:39 +00:00'} == set()\n\n  Extra items in the left set:\n  '2015-03-01 23:34:39 +00:00'\n  '2013-9-21 13:43:00Z'\n</code></pre>\n<p>As with the test I wrote <a href=\"https://alexwlchan.net/2025/detecting-av1-videos/#writing-a-test-to-find-videos-with-the-av1-codec\">in my last post</a>, I like to report on all the failing values, not just the first one.\nThis allows me to see the scale of the problem, and see patterns in the failing output \u2013 if I see a bad timestamp, is it a one-off issue I should fix by hand, or does it affect thousands of values that need an automatic cleanup?</p>\n\n<p>When I first ran this test, it failed with thousands of errors.\nI cleaned up the data and re-ran the test until it passed, and now I can keep running it to ensure no unexpected values sneak back in.</p>\n\n<h2 id=\"changing-the-format-of-date-strings-in-bulk\">Changing the format of date strings in bulk</h2>\n\n<p>This test revealed thousands of errors, and I didn\u2019t want to fix them all by hand.\nThat would be slow, tedious, and prone to manual errors.\nBut among the timestamps I wanted to change, there were pockets of consistency \u2013 each tool that contributed to this data would write timestamps in a single format, and I could convert all the timestamps from that tool in one go.</p>\n\n<p>I wrote one-off fixer scripts to perform these conversions.\nEach script would read the JSON file, look for date strings in a given format, convert them to my preferred format, then write the result back to my JSON file:\nHere\u2019s one example:</p>\n<pre><code>import <span class=\"n\">json</span>\n\n\n<span class=\"c1\"># e.g. 2001-02-03 04:05:06 +07:00\n</span><span class=\"n\">old_format</span> = <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%d %H:%M:%S %z</span><span class=\"sh\">\"</span>\n\n<span class=\"c1\"># e.g. 2001-02-03T04:05:06+07:00 (datetime.isoformat())\n</span><span class=\"n\">new_format</span> = <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span>\n\n\nwith open<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">my_data.json</span><span class=\"sh\">\"</span><span class=\"p\">)</span> as <span class=\"n\">in_file</span><span class=\"p\">:</span>\n    <span class=\"n\">json_data</span> = json<span class=\"p\">.</span>load<span class=\"p\">(</span>in_file<span class=\"p\">)</span>\n\nfor <span class=\"n\">json_obj</span><span class=\"p\">,</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span>json_data<span class=\"p\">):</span>\n    if date_matches_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> old_format<span class=\"p\">):</span>\n        <span class=\"n\">d</span> = datetime<span class=\"p\">.</span>strptime<span class=\"p\">(</span>date_string<span class=\"p\">,</span> old_format<span class=\"p\">)</span>\n        json_obj<span class=\"p\">[</span>key<span class=\"p\">]</span> = d<span class=\"p\">.</span>strftime<span class=\"p\">(</span>new_format<span class=\"p\">)</span>\n\nwith open<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">my_data.json</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">w</span><span class=\"sh\">\"</span><span class=\"p\">)</span> as <span class=\"n\">out_file</span><span class=\"p\">:</span>\n    out_file<span class=\"p\">.</span>write<span class=\"p\">(</span>json<span class=\"p\">.</span>dumps<span class=\"p\">(</span>json_data<span class=\"p\">,</span> indent=<span class=\"mi\">2</span><span class=\"p\">))</span>\n</code></pre>\n<p>I keep my JSON data files in Git, and I committed every time I ran a successful script.\nThat made it easy to see the changes from each fix-up, and to revert them if I made a mistake.</p>\n\n<p>The nice thing about this approach is that each script is quite small and simple, because it\u2019s only trying to fix one thing at a time.\nBut each script adds up, and <a href=\"https://en.wikipedia.org/wiki/Salami_slicing\">salami slicing</a> eventually ends up with dramatically cleaner data.\nI didn\u2019t fix everything this way (some typos were quicker to fix by hand), but scripting fixed the majority of issues.</p>\n\n<h2 id=\"putting-it-all-together\">Putting it all together</h2>\n\n<p>Here\u2019s what we\u2019ve done in this post:</p>\n\n<ul>\n  <li>Written a recursive function to find all the timestamps in a JSON value</li>\n  <li>Chosen the timestamp formats we allow, and added helpers to check them</li>\n  <li>Added a test to find and prevent unexpected formats</li>\n  <li>Written one-off migration scripts to clean up old timestamps</li>\n</ul>\n\n<p>Here\u2019s the final test which ties this all together.\nI\u2019ve saved it as <code>test_date_formats.py</code>:</p>\n<pre><code>from <span class=\"n\">collections</span><span class=\"p\">.</span><span class=\"n\">abc</span> import <span class=\"n\">Iterator</span>\nfrom <span class=\"n\">datetime</span> import <span class=\"n\">datetime</span>\nfrom <span class=\"n\">typing</span> import <span class=\"n\">Any</span>\n\n\ndef <span class=\"n\">find_all_dates</span><span class=\"p\">(</span><span class=\"n\">json_value</span><span class=\"p\">:</span> Any<span class=\"p\">)</span> -&gt; Iterator<span class=\"p\">[</span>tuple<span class=\"p\">[</span>dict<span class=\"p\">[</span>str<span class=\"p\">,</span> Any<span class=\"p\">],</span> str<span class=\"p\">,</span> str<span class=\"p\">]]:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Find all the timestamps in a heavily nested JSON object.\n\n    This function looks for any JSON objects with a key-value pair\n    where the key starts with `date_` and the value is a string, and\n    emits a 3-tuple:\n\n    *   the JSON object\n    *   the key\n    *   the value\n\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"c1\"># Case 1: JSON objects\n</span>    if isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> dict<span class=\"p\">):</span>\n        for <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"n\">value</span> <span class=\"ow\">in</span> json_value<span class=\"p\">.</span>items<span class=\"p\">():</span>\n            if <span class=\"p\">(</span>\n                isinstance<span class=\"p\">(</span>key<span class=\"p\">,</span> str<span class=\"p\">)</span>\n                <span class=\"ow\">and</span> key<span class=\"p\">.</span>startswith<span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">date_</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n                <span class=\"ow\">and</span> isinstance<span class=\"p\">(</span>value<span class=\"p\">,</span> str<span class=\"p\">)</span>\n            <span class=\"p\">):</span>\n                yield json_value<span class=\"p\">,</span> key<span class=\"p\">,</span> value\n            else<span class=\"p\">:</span>\n                yield from find_all_dates<span class=\"p\">(</span>value<span class=\"p\">)</span>\n\n    <span class=\"c1\"># Case 2: JSON arrays\n</span>    elif isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> list<span class=\"p\">):</span>\n        for <span class=\"n\">value</span> <span class=\"ow\">in</span> json_value<span class=\"p\">:</span>\n            yield from find_all_dates<span class=\"p\">(</span>value<span class=\"p\">)</span>\n\n    <span class=\"c1\"># Case 3: other JSON types\n</span>    elif isinstance<span class=\"p\">(</span>json_value<span class=\"p\">,</span> <span class=\"p\">(</span>str<span class=\"p\">,</span> int<span class=\"p\">,</span> bool<span class=\"p\">))</span> <span class=\"ow\">or</span> json_value <span class=\"ow\">is</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n        return <span class=\"p\">[]</span>\n\n    <span class=\"c1\"># Case 4: handle unexpected types\n</span>    else<span class=\"p\">:</span>\n        raise TypeError<span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"sh\">\"</span><span class=\"s\">Unexpected type: </span><span class=\"si\">{</span>type<span class=\"p\">(</span>json_value<span class=\"p\">)</span><span class=\"si\">}</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n\n\ndef <span class=\"n\">date_matches_format</span><span class=\"p\">(</span><span class=\"n\">date_string</span><span class=\"p\">:</span> str<span class=\"p\">,</span> <span class=\"n\">format</span><span class=\"p\">:</span> str<span class=\"p\">)</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if `date_string` can be parsed as a datetime\n    using `format`, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    try<span class=\"p\">:</span>\n        datetime<span class=\"p\">.</span>strptime<span class=\"p\">(</span>date_string<span class=\"p\">,</span> format<span class=\"p\">)</span>\n        return <span class=\"bp\">True</span>\n    except ValueError<span class=\"p\">:</span>\n        return <span class=\"bp\">False</span>\n\n\ndef <span class=\"n\">date_matches_any_format</span><span class=\"p\">(</span><span class=\"n\">date_string</span><span class=\"p\">:</span> str<span class=\"p\">,</span> <span class=\"n\">formats</span><span class=\"p\">:</span> tuple<span class=\"p\">[</span>str<span class=\"p\">])</span> -&gt; bool<span class=\"p\">:</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    Returns True if `date_string` can be parsed as a datetime\n    with any of the `formats`, False otherwise.\n    </span><span class=\"sh\">\"\"\"</span>\n    return any<span class=\"p\">(</span>\n        date_matches_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> fmt<span class=\"p\">)</span>\n        for <span class=\"n\">fmt</span> <span class=\"ow\">in</span> formats\n    <span class=\"p\">)</span>\n\n\ndef <span class=\"n\">test_all_timestamps_are_consistent</span><span class=\"p\">():</span>\n    <span class=\"sh\">\"\"\"</span><span class=\"s\">\n    All the timestamps in my JSON use a consistent format.\n\n    See https://alexwlchan.net/2025/messy-dates-in-json/\n    </span><span class=\"sh\">\"\"\"</span>\n    <span class=\"c1\"># TODO: Write code for reading JSON_DATA\n</span>\n    <span class=\"n\">allowed_formats</span> = <span class=\"p\">(</span>\n        <span class=\"c1\"># 2001-02-03T04:05:06+07:00\n</span>        <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%dT%H:%M:%S%z</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n        <span class=\"c1\">#\n</span>        <span class=\"c1\"># 2001-02-03\n</span>        <span class=\"sh\">\"</span><span class=\"s\">%Y-%m-%d</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n    <span class=\"p\">)</span>\n\n    <span class=\"n\">bad_date_strings</span> = <span class=\"p\">{</span>\n        date_string\n        for _<span class=\"p\">,</span> _<span class=\"p\">,</span> <span class=\"n\">date_string</span> <span class=\"ow\">in</span> find_all_dates<span class=\"p\">(</span>JSON_DATA<span class=\"p\">)</span>\n        if <span class=\"ow\">not</span> date_matches_any_format<span class=\"p\">(</span>date_string<span class=\"p\">,</span> allowed_formats<span class=\"p\">)</span>\n    <span class=\"p\">}</span>\n\n    assert bad_date_strings == set<span class=\"p\">()</span>\n</code></pre>\n<p>If you want to use this test, you\u2019ll need to modify it to read your JSON data, and to specify the list of timestamp formats you accept.</p>\n\n<p>Although I\u2019ve since cleaned up the data so it has a more consistent structure, this test has remained as-is.\nI could write a more specific test that knows about my JSON schema and looks for timestamps in specific fields, but I quite like having a generic test that doesn\u2019t need to change when I change my data model.\nThe flexibility also means it\u2019s easy to copy across projects, and I\u2019ve reused this test almost unmodified in several tests already.</p>\n\n\n    <p>[If the formatting of this post looks odd in your feed reader, <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/?ref=rss\">visit the original article</a>]</p>"
            ],
            "link": "https://alexwlchan.net/2025/messy-dates-in-json/?ref=rss",
            "publishedAt": "2025-11-17",
            "source": "Alex Chan",
            "summary": "<p>I\u2019ve been cleaning up some messy data, and it includes timestamps written by a variety of humans and machines, which don\u2019t use a consistent format.</p> <p>Here are a few examples:</p> <pre><code>2025-10-14T05:34:07+0000 2015-03-01 23:34:39 +00:00 2013-9-21 13:43:00Z 2024-08-30 </code></pre> <p>All of these timestamps are machine-readable, but it would be easier for the downstream code if there weren\u2019t as many different formats. For example, the downstream code uses the JavaScript <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/Date\"><code>Date()</code> constructor</a>, which rejects some of the timestamps as invalid.</p> <p>I wrote a Python script to help me find, validate, and normalise all my timestamps, so the rest of my code can deal with a more consistent set.</p> <blockquote class=\"table_of_contents\"> <h3>Table of contents</h3> <ul> <li> <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#finding-all-the-data-strings\">Finding all the data strings</a> </li> <li> <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#checking-if-a-date-string-matches-a-given-format\">Checking if a date string matches a given format</a> </li> <li> <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#testing-that-all-of-my-timestamps-use-consistent-formats\">Testing that all of my timestamps use consistent formats</a> </li> <li> <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#changing-the-format-of-date-strings-in-bulk\">Changing the format of date strings in bulk</a> </li> <li> <a href=\"https://alexwlchan.net/2025/messy-dates-in-json/#putting-it-all-together\">Putting it all together</a> </li> </ul> </blockquote> <h2 id=\"finding-all-the-data-strings\">Finding all the data strings</h2> <p>All the messy data is in JSON, and the structure is quite inconsistent \u2013 a lot of heavily nested objects, differently-named fields, varying models and schemas. This project is",
            "title": "Cleaning up messy dates in JSON"
        },
        {
            "content": [
                "<p>AI has been compared to various historical precedents: electricity, industrial revolution, etc., I think the strongest analogy is that of AI as a new computing paradigm because both are fundamentally about the automation of digital information processing.</p>\n<p>If you were to forecast the impact of computing on the job market in ~1980s, the most predictive feature of a task/job you'd look at is <strong>specifiability</strong>, i.e. are you just mechanically transforming information according to rote, easy to specify algorithm (examples being typing, bookkeeping, human calculators, etc.)? Back then, this was the class of programs that the computing capability of that era allowed us to write (by hand, manually). I call hand-written programs \"Software 1.0\".</p>\n<p>With AI now, we are able to write new programs that we could never hope to write by hand before. We do it by specifying objectives (e.g. classification accuracy, reward functions), and we search the program space via gradient descent to find neural networks that work well against that objective. This is my <a href=\"https://karpathy.medium.com/software-2-0-a64152b37c35\">Software 2.0 blog post</a> from a while ago. In this new programming paradigm then, the new most predictive feature to look at is <strong>verifiability</strong>. If a task/job is verifiable, then it is optimizable directly or via reinforcement learning, and a neural net can be trained to work extremely well. It's about to what extent an AI can \"practice\" something. The environment has to be:</p>\n<ul>\n<li>resettable (you can start a new attempt),</li>\n<li>efficient (a lot attempts can be made) and</li>\n<li>rewardable (there is some automated process to reward any specific attempt that was made).</li>\n</ul>\n<p>The more a task/job is verifiable, the more amenable it is to automation in the new programming paradigm. If it is not verifiable, it has to fall out from neural net magic of generalization fingers crossed, or via weaker means like imitation. This is what's driving the \"jagged\" frontier of progress in LLMs. Tasks that are verifiable progress rapidly, including possibly beyond the ability of top experts (e.g. math, code, amount of time spent watching videos, anything that looks like puzzles with correct answers), while many others lag by comparison (creative, strategic, tasks that combine real-world knowledge, state, context and common sense).</p>\n<ul>\n<li>Software 1.0 easily automates what you can specify.</li>\n<li>Software 2.0 easily automates what you can verify.</li>\n</ul>"
            ],
            "link": "https://karpathy.bearblog.dev/verifiability/",
            "publishedAt": "2025-11-17",
            "source": "Andrej Karpathy",
            "summary": "<p>AI has been compared to various historical precedents: electricity, industrial revolution, etc., I think the strongest analogy is that of AI as a new computing paradigm because both are fundamentally about the automation of digital information processing.</p> <p>If you were to forecast the impact of computing on the job market in ~1980s, the most predictive feature of a task/job you'd look at is <strong>specifiability</strong>, i.e. are you just mechanically transforming information according to rote, easy to specify algorithm (examples being typing, bookkeeping, human calculators, etc.)? Back then, this was the class of programs that the computing capability of that era allowed us to write (by hand, manually). I call hand-written programs \"Software 1.0\".</p> <p>With AI now, we are able to write new programs that we could never hope to write by hand before. We do it by specifying objectives (e.g. classification accuracy, reward functions), and we search the program space via gradient descent to find neural networks that work well against that objective. This is my <a href=\"https://karpathy.medium.com/software-2-0-a64152b37c35\">Software 2.0 blog post</a> from a while ago. In this new programming paradigm then, the new most predictive feature to look at is <strong>verifiability</strong>. If a task/job is verifiable, then it is optimizable",
            "title": "Verifiability"
        },
        {
            "content": [
                "<p>This is the weekly visible open thread. Post about anything you want, ask random questions, whatever. ACX has an unofficial <a href=\"https://www.reddit.com/r/slatestarcodex/\">subreddit</a>, <a href=\"https://discord.gg/RTKtdut\">Discord</a>, and <a href=\"https://www.datasecretslox.com/index.php\">bulletin board</a>, and <a href=\"https://www.lesswrong.com/community?filters%5B0%5D=SSC\">in-person meetups around the world</a>. Most content is free, some is subscriber only; you can subscribe <strong><a href=\"https://astralcodexten.substack.com/subscribe\">here</a></strong>. Also:</p><div><hr /></div><p><strong>1: </strong>A few months ago, I advertised a CBT-for-insomnia company called <a href=\"https://www.gnsheep.com/\">Sheep-Sleep</a> here. I&#8217;m very interested in learning more about how well it works. If you tried it based on my recommendation, or for any other reason, can you send me an email at scott[at]slatestarcodex[dot]com and tell me how it&#8217;s going?</p><p><strong>2: </strong>Big EA funder Open Philanthropy is looking for more AI safety grantmakers to help direct $100 million to the best alignment research. Ideal candidates will have familiarity with the field, high technical literacy, and good judgment. Compensation is $125K - $285K++ depending on role/level/experience, remote work possible but SF Bay location preferred, US visa sponsorship possible, application deadline is November 24th. <a href=\"https://jobs.ashbyhq.com/openphilanthropy/4e210168-34c5-43c5-9f97-8767834f8c42\">See here for more</a>.</p><p><strong>3: </strong>ACX Grantee <a href=\"https://www.growth-teams.org/\">Growth Teams</a> works on developing-country economic growth; their latest work is exploring export booms. They write: &#8220;Export-led growth isn&#8217;t rare or unattainable&#8211;it&#8217;s happened again and again, across regions and industries...but often these cases and the stories behind them are not commonly known, even by international development experts. We created the <strong><a href=\"https://exportbooms.org/\">Export Boom Atlas</a></strong> to document these export booms &#8211; what happened and the key factors that spurred growth.&#8221;</p>"
            ],
            "link": "https://www.astralcodexten.com/p/open-thread-408",
            "publishedAt": "2025-11-17",
            "source": "SlateStarCodex",
            "summary": "<p>This is the weekly visible open thread. Post about anything you want, ask random questions, whatever. ACX has an unofficial <a href=\"https://www.reddit.com/r/slatestarcodex/\">subreddit</a>, <a href=\"https://discord.gg/RTKtdut\">Discord</a>, and <a href=\"https://www.datasecretslox.com/index.php\">bulletin board</a>, and <a href=\"https://www.lesswrong.com/community?filters%5B0%5D=SSC\">in-person meetups around the world</a>. Most content is free, some is subscriber only; you can subscribe <strong><a href=\"https://astralcodexten.substack.com/subscribe\">here</a></strong>. Also:</p><div><hr /></div><p><strong>1: </strong>A few months ago, I advertised a CBT-for-insomnia company called <a href=\"https://www.gnsheep.com/\">Sheep-Sleep</a> here. I&#8217;m very interested in learning more about how well it works. If you tried it based on my recommendation, or for any other reason, can you send me an email at scott[at]slatestarcodex[dot]com and tell me how it&#8217;s going?</p><p><strong>2: </strong>Big EA funder Open Philanthropy is looking for more AI safety grantmakers to help direct $100 million to the best alignment research. Ideal candidates will have familiarity with the field, high technical literacy, and good judgment. Compensation is $125K - $285K++ depending on role/level/experience, remote work possible but SF Bay location preferred, US visa sponsorship possible, application deadline is November 24th. <a href=\"https://jobs.ashbyhq.com/openphilanthropy/4e210168-34c5-43c5-9f97-8767834f8c42\">See here for more</a>.</p><p><strong>3: </strong>ACX Grantee <a href=\"https://www.growth-teams.org/\">Growth Teams</a> works on developing-country economic growth; their latest work is exploring export booms. They write: &#8220;Export-led growth isn&#8217;t rare or unattainable&#8211;it&#8217;s happened again and again, across regions and industries...but",
            "title": "Open Thread 408"
        },
        {
            "content": [],
            "link": "https://xkcd.com/3169/",
            "publishedAt": "2025-11-17",
            "source": "XKCD",
            "summary": "<img alt=\"'Oh no, the box is drifting out into the harbor!' 'Yeah, I wouldn't worry about losing it.'\" src=\"https://imgs.xkcd.com/comics/epirbs.png\" title=\"'Oh no, the box is drifting out into the harbor!' 'Yeah, I wouldn't worry about losing it.'\" />",
            "title": "EPIRBs"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2025-11-17"
}
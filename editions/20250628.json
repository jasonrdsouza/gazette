{
    "articles": [
        {
            "content": [],
            "link": "https://harper.blog/notes/2025-06-28_0f560211ef82_more-from-jikka/",
            "publishedAt": "2025-06-28",
            "source": "Harper Reed",
            "summary": "<p>More from Jikka</p> <figure> <img alt=\"image_1.jpg\" height=\"1196\" src=\"https://harper.blog/notes/2025-06-28_0f560211ef82_more-from-jikka/image_1.jpg\" width=\"1799\" /> </figure> <figure> <img alt=\"image_2.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-06-28_0f560211ef82_more-from-jikka/image_2.jpg\" width=\"1800\" /> </figure> <hr /> <p>Thank you for using RSS. I appreciate you. <a href=\"mailto:harper&#64;modest.com\">Email me</a></p>",
            "title": "Note #267"
        },
        {
            "content": [],
            "link": "https://harper.blog/notes/2025-06-28_41d971c0b29f_went-to-an-amazing-restaurant-/",
            "publishedAt": "2025-06-28",
            "source": "Harper Reed",
            "summary": "<p>Went to an amazing restaurant in Izu called Jikka. Highly recommend visiting.</p> <figure> <img alt=\"image_1.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-06-28_41d971c0b29f_went-to-an-amazing-restaurant-/image_1.jpg\" width=\"1800\" /> </figure> <figure> <img alt=\"image_2.jpg\" height=\"1800\" src=\"https://harper.blog/notes/2025-06-28_41d971c0b29f_went-to-an-amazing-restaurant-/image_2.jpg\" width=\"1800\" /> </figure> <hr /> <p>Thank you for using RSS. I appreciate you. <a href=\"mailto:harper&#64;modest.com\">Email me</a></p>",
            "title": "Note #266"
        },
        {
            "content": [
                "<p>One of the most common complaints I hear from users of AI agents is, \"Why do I have to tell it the same thing over and over?\" They expect their tools to learn from experience, but the reality is that most don't. This is because today's LLM-powered apps are fundamentally static; they don't learn purely from individual interactions.<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-1\" id=\"footnote-anchor-1\" target=\"_self\">1</a></p><p>As building agents becomes better defined and many products have shipped their first agentic MVPs, what&#8217;s becoming clear is that the next new thing may be how to get these agents to reliably and securely self-improve. This applies to both <strong>knowledge</strong> (gaining persistent user-related context) and <strong>behavior</strong> (learning to more effectively solve problems) which are independent but highly interrelated. In some online contexts, you&#8217;ll see this referred to as agent &#8220;memory,&#8221; and to me, that's just an implementation for achieving this experience.</p><p>If machine learning (ML) was supposed to &#8220;<a href=\"https://en.wikipedia.org/wiki/Machine_learning\">learn from experience E with respect to some class of tasks T</a>&#8230;&#8221; why are our GPT wrappers, built using ML, not actually learning from experience? The answer is: technically they could, but training these next-token-prediction models is actually a fairly non-trivial problem compared to their task-specific classification/regression/etc counterparts.</p><p>In this post, I wanted to go through the modern toolbox for agent self-improvement and why it&#8217;s complicated.<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-2\" id=\"footnote-anchor-2\" target=\"_self\">2</a></p><div class=\"captioned-image-container\"><figure><a class=\"image-link image2 is-viewable-img\" href=\"https://substackcdn.com/image/fetch/$s_!LX_Y!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7904d27c-9bdc-4615-a55f-9923f2f57715_1536x1024.png\" target=\"_blank\"><div class=\"image2-inset\"><source type=\"image/webp\" /><img alt=\"\" class=\"sizing-normal\" height=\"356.12225274725273\" src=\"https://substackcdn.com/image/fetch/$s_!LX_Y!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F7904d27c-9bdc-4615-a55f-9923f2f57715_1536x1024.png\" width=\"534\" /><div class=\"image-link-expand\"><div class=\"pencraft pc-display-flex pc-gap-8 pc-reset\"><div class=\"pencraft pc-reset icon-container restack-image\"><svg class=\"lucide lucide-refresh-cw\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path><path d=\"M21 3v5h-5\"></path><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path><path d=\"M8 16H3v5\"></path></svg></div><div class=\"pencraft pc-reset icon-container view-image\"><svg class=\"lucide lucide-maximize2\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"></line><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"></line></svg></div></div></div></div></a><figcaption class=\"image-caption\"><em>&#8220;How to Train Your GPT Wrapper&#8221;</em> by ChatGPT.</figcaption></figure></div><h2>Why is self-learning hard?</h2><ul><li><p><strong>Training (as in updating parameters) LLMs is still hard</strong><a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-3\" id=\"footnote-anchor-3\" target=\"_self\">3</a></p><ul><li><p>If you have a knowledge base, you can&#8217;t just &#8220;train&#8221; on it. Traditional Supervised Fine-Tuning (SFT) requires a large dataset of conversational examples (<code>user_question</code>, <code>expected_response</code>) rather than just knowledge material.</p></li><li><p>If you are building a tool-use agent or a reasoning model, you often can&#8217;t train on just examples but instead rely on reinforcement learning to steer the model towards a reward. This takes quite a bit more compute, relies on a high quality reward function (which isn&#8217;t maximizing user ratings!<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-4\" id=\"footnote-anchor-4\" target=\"_self\">4</a>), and either user data or highly realistic simulated environments.</p></li><li><p>While you can attempt to anonymize, a global model trained on one user's data still has the potential to leak information to others<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-5\" id=\"footnote-anchor-5\" target=\"_self\">5</a>. While fine-tuning on synthetic data is an option for enterprises with privacy concerns, generating high-quality synthetic data is a significant challenge, often making this a non-starter in practice.</p></li><li><p>Today's models have hundreds of billions of parameters with quite a bit of complexity around how to both train and serve them. While we&#8217;ve developed several ways of efficiently fine-tuning, there&#8217;s no platform (yet) that makes it trivial to regularly turn feedback into new, servable models.<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-6\" id=\"footnote-anchor-6\" target=\"_self\">6</a></p></li></ul></li><li><p><strong>Training (as in prompting, aka <a href=\"https://arxiv.org/abs/2301.00234\">in-context-learning</a>) is costly</strong></p><ul><li><p>Every piece of information added to the prompt, past conversations, tool outputs, user feedback, consumes tokens. This makes naive feedback quadratic in cost and latency as each interaction potentially generates feedback which is appended to the prompt in every future interaction.</p></li><li><p>Applications rely heavily on prompt caching to manage costs. However, the more you personalize the context with user-specific rules and feedback, the lower your cache hit rate becomes.</p></li></ul></li><li><p><strong>State makes everything more complicated</strong><a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-7\" id=\"footnote-anchor-7\" target=\"_self\">7</a></p><ul><li><p>Once an agent starts learning, its past interactions can influence future behavior. Did the agent give a bad response because of a recent change in the system prompt, a new feature, or a piece of user feedback from three weeks ago? The \"blast radius\" of a single piece of learned information is hard to predict and control.</p></li><li><p>What happens when a user's preferences change, or when information becomes outdated? A system that can't effectively forget is doomed to make mistakes based on old, irrelevant data. Imagine telling your agent to never answer questions on a certain topic, but then a product update makes that topic relevant again. The agent's \"memory\" might prevent it from adapting.</p></li><li><p>For any of this to work, users have to trust you with their data and their feedback. This brings us back to the data leakage problem. There's an inherent tension between creating a globally intelligent system that learns from all users and a personalized one that respects individual privacy.</p></li></ul></li></ul><div class=\"subscription-widget-wrap-editor\"><div class=\"subscription-widget show-subscribe\"><div class=\"preamble\"><p class=\"cta-caption\">Thanks for reading Shrivu&#8217;s Substack! Subscribe for free to receive new posts and support my work.</p></div><form class=\"subscription-widget-subscribe\"><input class=\"email-input\" name=\"email\" tabindex=\"-1\" type=\"email\" /><input class=\"button primary\" type=\"submit\" value=\"Subscribe\" /><div class=\"fake-input-wrapper\"><div class=\"fake-input\"></div><div class=\"fake-button\"></div></div></form></div></div><h2>How self-learning works depends on the type of feedback and its effect radius.</h2><p>The core determiner for how you do self-improvement is what data you can get from the user, ranging from nothing at all to detailed corrections and explanations. The richer the feedback, the less samples needed to make a meaningful improvement.</p><p>It&#8217;s also a key product decision to determine the effect radius for different forms of feedback. I&#8217;ll call this the &#8220;preference group&#8221;; the group of users (or interactions) in which a given piece of feedback causes a change in agent behavior. These groups could be along explicit boundaries (by user, team, or other legal organization) or derived boundaries (geographic region, working file paths, usage persona, etc).</p><ul><li><p><strong>Grouping too small</strong> (e.g. user level) increases cold start friction and means several users will experience the same preventable mistakes, some never seeing any improvement until they provide sufficient feedback. For parameter-based training, it can also be unmanageable to have highly granular copies of the model weights (even if from PEFT).</p></li><li><p><strong>Grouping too large</strong> (e.g. globally) leads to riskier agent updates and unusual behavior. One user with &#8220;weird&#8221; feedback could directly degrade the efficacy of the agent for all other users.</p></li></ul><h3>Case 0: Users give you nothing</h3><p>Even when you have no explicit signal from the user on how your agent is performing you can improve the system. While users get a potentially more focused experience, with a lack of signal, you&#8217;ll need to derive approximate feedback from high-volume, low-signal proxy data. There&#8217;s high potential to make false assumptions but this can be compensated for my aggregating more data (i.e. over time or preference group size) per model update.</p><p><strong>What you could do:</strong></p><ul><li><p><strong>Use LLMs to determine preferences or explanations</strong> &#8212; Take (question, answer) pairs and use LLMs (or even simpler heuristics) to determine if this was a preferred answer or what the preferred answer would have been. Effectively running your own LLM-as-judge setup to determine what the user might&#8217;ve told you<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-8\" id=\"footnote-anchor-8\" target=\"_self\">8</a>. With this, proceed to cases 1, 2, or 3.</p></li><li><p><strong>Use engagement metrics to determine preferences</strong> &#8212; Take traditional analytics on engagement with your agent to approximate the quality of responses. Did the user come back? Did the buy the thing you showed them? How much time did they spend? Turning these types of analytics into preferences on your agent&#8217;s responses. With this, proceed to case 1.</p></li><li><p><strong>Use agent tool failures as implicit signals </strong>&#8212; You can log every tool call and its outcome (success, failure, or the content of the response). Recurring tool failures, inefficient tool-use loops, or patterns where the agent calls a tool with nonsensical arguments are all strong implicit signals that the agent's reasoning is flawed for a particular type of task. These failed \"trajectories\" can be automatically flagged and used as negative examples for Case 1.</p></li><li><p><strong>Use simulation to generate feedback</strong> &#8212; Use an LLM to act as a \"user simulator\", generating a diverse set of realistic queries and tasks. Then, have your agent attempt to solve these tasks in a synthetic gym environment. Since you define the environment and task, you can often automatically verify if the agent succeeded (e.g., \"Did it pass the tests?\") and use this outcome as a reward signal. This synthetic data can then be used to create preference pairs or corrections, allowing you to train your agent using the methods from cases 1, 2, or 3.</p></li><li><p><strong>Keep the chat history</strong> &#8212; While their are plenty of reasons this might make things worse, another option when there&#8217;s no clear preferences or feedback is provided is to just include the previous chats (or chat summaries) in future prompts within the same preference group. You do this with the hope that the collective context of previous chats, the agent can steer towards better responses. </p></li><li><p><strong>Rely on third-party grounding</strong> &#8212; You could also rely on a 3rd party API to give the agents hints or updated instructions for how to solve a particular task. A simple example of this would be to have an agent that can &#8220;google&#8221; for how to solve the problem and as google indexes online posts, your agent <em>might</em> natural begin to improve. For any given agent you are building, there might be some pre-existing knowledge base you can lean on for &#8220;self-improvement&#8221;.</p></li></ul><div class=\"captioned-image-container\"><figure><a class=\"image-link image2 is-viewable-img\" href=\"https://substackcdn.com/image/fetch/$s_!WrF4!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F47400727-1120-444d-87f9-97767c3abc9d_1536x1024.png\" target=\"_blank\"><div class=\"image2-inset\"><source type=\"image/webp\" /><img alt=\"\" class=\"sizing-normal\" height=\"342.78434065934067\" src=\"https://substackcdn.com/image/fetch/$s_!WrF4!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F47400727-1120-444d-87f9-97767c3abc9d_1536x1024.png\" width=\"514\" /><div class=\"image-link-expand\"><div class=\"pencraft pc-display-flex pc-gap-8 pc-reset\"><div class=\"pencraft pc-reset icon-container restack-image\"><svg class=\"lucide lucide-refresh-cw\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path><path d=\"M21 3v5h-5\"></path><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path><path d=\"M8 16H3v5\"></path></svg></div><div class=\"pencraft pc-reset icon-container view-image\"><svg class=\"lucide lucide-maximize2\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"></line><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"></line></svg></div></div></div></div></a></figure></div><h3>Case 1: Users give preferences (&#128077;&#128078;)</h3><p>This is one of the most common feedback mechanisms. It's low-friction for the user, provides a clear signal that can be easily turned into a metric, and is a step up from inferring feedback from proxy data. However, the signal itself can be noisy. Users might downvote a correct answer because it was unhelpful for their specific need, or upvote an incorrect one that just <em>sounds</em> confident.</p><p><strong>What you could do:</strong></p><ul><li><p><strong>Fine-tune with preferences</strong> &#8212; You can train the model by constructing <code>(chosen, rejected)</code> pairs from the data you collect. A response that receives a &#128077; becomes a \"chosen\" example, while one that gets a &#128078; becomes a \"rejected\" one, and these are then paired for training. From there, classic RLHF can use these pairs to train a reward model that guides the main agent. A more direct alternative is DPO, which skips the reward model and uses the constructed pairs to directly fine-tune the agent's policy.</p></li><li><p><strong>Use LLMs to derive explanations</strong> &#8212; Aggregate the &#128077;/&#128078; data across a preference group and use another LLM to analyze the patterns and generate a hypothesis for <em>why</em> certain responses were preferred. This process attempts to turn many low-quality signals into a single, higher-quality explanation, which you can then use to update documentation or create few-shot examples as described in Case 2.</p></li><li><p><strong>Use in-context learning with examples</strong> &#8212; Dynamically pull examples of highly-rated and poorly-rated responses and place them into the context window for future queries within the same preference group. This lets the agent \"learn\" at inference time to steer its answers towards a preferred style or content format.</p></li></ul><div class=\"captioned-image-container\"><figure><a class=\"image-link image2 is-viewable-img\" href=\"https://substackcdn.com/image/fetch/$s_!Ki9y!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5a4eddcc-7e96-4b3e-aa1f-3bf5ab2e145b_1536x1024.png\" target=\"_blank\"><div class=\"image2-inset\"><source type=\"image/webp\" /><img alt=\"\" class=\"sizing-normal\" height=\"364.125\" src=\"https://substackcdn.com/image/fetch/$s_!Ki9y!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5a4eddcc-7e96-4b3e-aa1f-3bf5ab2e145b_1536x1024.png\" width=\"546\" /><div class=\"image-link-expand\"><div class=\"pencraft pc-display-flex pc-gap-8 pc-reset\"><div class=\"pencraft pc-reset icon-container restack-image\"><svg class=\"lucide lucide-refresh-cw\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path><path d=\"M21 3v5h-5\"></path><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path><path d=\"M8 16H3v5\"></path></svg></div><div class=\"pencraft pc-reset icon-container view-image\"><svg class=\"lucide lucide-maximize2\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"></line><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"></line></svg></div></div></div></div></a></figure></div><h3>Case 2: Users give you explanations</h3><p>Here, instead of a simple preference, the user provides a natural language explanation of what went wrong (e.g., \"That's not right, you should have considered the legacy API,\" or \"Don't use that library, it's deprecated.\"). This feedback requires more effort from the user, but the signal quality is extremely high; a single good explanation can be more valuable than hundreds of thumbs-ups. Users are often willing to provide this level of detail if they believe the agent will actually learn from it and save them time in the future. This feedback can be collected through an explicit UI, in the flow of conversation, or even inferred from subsequent user actions.</p><p><strong>What you could do:</strong></p><ul><li><p><strong>Synthesize a corrected answer</strong> &#8212; One use of an explanation is to try and generate the corrected answer. You can use another LLM as a \"refiner\" that takes the <code>(original_response, user_explanation)</code> and outputs a <code>corrected_response</code>. If this synthesis is successful, you've effectively created a high-quality <code>(original_response, corrected_response)</code> pair and can move to Case 3.</p></li><li><p><strong>Use in-context learning with explanations</strong> &#8212; Store the <code>(response, user_explanation)</code> pairs. When a new, similar query comes in, you can retrieve the most relevant pairs and inject them into the prompt. This gives the agent a just-in-time example of a pitfall to avoid and the reasoning behind it, steering it away from making the same mistake twice or doubling down on what worked.</p></li><li><p><strong>Distill feedback into reusable knowledge</strong> &#8212; Aggregate explanations to find recurring issues&#8212;like an agent's travel suggestions being too generic. An LLM can then synthesize these complaints into a single, concise rule. This new rule can either be added to the system prompt to fix the behavior for a user group, or it can be inserted into a knowledge base. For example, a synthesized rule like, \"When planning itineraries, always include a mix of popular sites and unique local experiences,\" can be stored and retrieved for any future travel-related queries, ensuring more personalized and higher-quality suggestions.</p></li></ul><div class=\"captioned-image-container\"><figure><a class=\"image-link image2 is-viewable-img\" href=\"https://substackcdn.com/image/fetch/$s_!nuCu!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd90d20a2-8402-4fb8-8104-95270bb32d9c_1536x1024.png\" target=\"_blank\"><div class=\"image2-inset\"><source type=\"image/webp\" /><img alt=\"\" class=\"sizing-normal\" height=\"324.77815934065933\" src=\"https://substackcdn.com/image/fetch/$s_!nuCu!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fd90d20a2-8402-4fb8-8104-95270bb32d9c_1536x1024.png\" width=\"487\" /><div class=\"image-link-expand\"><div class=\"pencraft pc-display-flex pc-gap-8 pc-reset\"><div class=\"pencraft pc-reset icon-container restack-image\"><svg class=\"lucide lucide-refresh-cw\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path><path d=\"M21 3v5h-5\"></path><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path><path d=\"M8 16H3v5\"></path></svg></div><div class=\"pencraft pc-reset icon-container view-image\"><svg class=\"lucide lucide-maximize2\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"></line><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"></line></svg></div></div></div></div></a></figure></div><p></p><h3>Case 3: Users give you edits</h3><p>Here, the user doesn't just explain what's wrong; they provide the correct answer by directly editing the agent's output. The \"diff\" between the agent's suggestion and the user's final version creates a high-quality training example. Depending on the product's design, this can often be a low-friction way to gather feedback, as the user was going to make the correction anyway as part of their natural workflow, whether they're fixing a block of generated code or rewriting a paragraph in a document.</p><p><strong>What you could do:</strong></p><ul><li><p><strong>Fine-tune with edit pairs</strong> &#8212; Use the <code>(query, user_edited_response)</code> pair for Supervised Fine-Tuning (SFT) to teach the model the correct behavior. Alternatively, you can use the <code>(original_response, user_edited_response)</code> pair for preference tuning methods like DPO, treating the user's edit as the \"chosen\" response and the agent's initial attempt as the \"rejected\" one.</p></li><li><p><strong>Use in-context learning with corrections &#8212; </strong>Store the <code>(question, user_edited_diff)</code> pairs. When a similar query comes in, you can retrieve the most relevant pairs and inject them into the prompt as a concrete example of what to do and what to avoid, steering the agent toward the correct format or content at inference time.</p></li><li><p><strong>Derive explanations</strong> &#8212; You can also work backward from the edit to enrich your prompts and/or knowledge bases. Use an LLM to analyze the \"diff\" between the original and edited text to generate a natural language explanation for the change, in some sense capturing the user's intent. This synthesized explanation can then be used in all the ways described in Case 2.</p></li></ul><div class=\"captioned-image-container\"><figure><a class=\"image-link image2 is-viewable-img\" href=\"https://substackcdn.com/image/fetch/$s_!B8wr!,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fad65d95d-1af9-490d-9b49-65dedbc4e1c8_1536x1024.png\" target=\"_blank\"><div class=\"image2-inset\"><source type=\"image/webp\" /><img alt=\"\" class=\"sizing-normal\" height=\"320.1098901098901\" src=\"https://substackcdn.com/image/fetch/$s_!B8wr!,w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fad65d95d-1af9-490d-9b49-65dedbc4e1c8_1536x1024.png\" width=\"480\" /><div class=\"image-link-expand\"><div class=\"pencraft pc-display-flex pc-gap-8 pc-reset\"><div class=\"pencraft pc-reset icon-container restack-image\"><svg class=\"lucide lucide-refresh-cw\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8\"></path><path d=\"M21 3v5h-5\"></path><path d=\"M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16\"></path><path d=\"M8 16H3v5\"></path></svg></div><div class=\"pencraft pc-reset icon-container view-image\"><svg class=\"lucide lucide-maximize2\" fill=\"none\" height=\"20\" stroke=\"currentColor\" stroke-linecap=\"round\" stroke-linejoin=\"round\" stroke-width=\"2\" viewBox=\"0 0 24 24\" width=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"15 3 21 3 21 9\"></polyline><polyline points=\"9 21 3 21 3 15\"></polyline><line x1=\"21\" x2=\"14\" y1=\"3\" y2=\"10\"></line><line x1=\"3\" x2=\"10\" y1=\"21\" y2=\"14\"></line></svg></div></div></div></div></a></figure></div><h2>Other considerations</h2><ul><li><p><strong>How do you handle observability and debuggability?</strong> &#8212; When an agent's \"memory\" causes unexpected behavior, debugging becomes a challenge. A key design choice is whether to provide users with an observable \"memory\" panel to view, edit, or reset learned information. This creates a trade-off between debuggability and the risk of overwhelming or confusing users with their own data profile.</p></li><li><p><strong>How do you pick the \"preference group\"?</strong> &#8212; Choosing the scope for feedback involves a trade-off between cold-starts and risk. User-level learning is slow to scale, while global learning can be degraded by outlier feedback. A common solution is grouping users by explicit boundaries (like a company) or implicit ones (like a usage persona). The design of these groups also has business implications; a group could be defined to span across both free and paid tiers, allowing feedback from a large base of unpaid users to directly improve the product for paying customers.</p></li><li><p><strong>How do you decide which feedback case to use?</strong> &#8212; The progression from simple preferences (Case 1) to detailed explanations or edits (Cases 2 &amp; 3) depends heavily on user trust. Users will only provide richer feedback when they believe the system is actually listening. This trust can be accelerated by making the agent's reasoning process transparent, which empowers users to self-debug and provide more targeted suggestions.</p></li><li><p><strong>How much should be learned via fine-tuning vs. in-context learning?</strong> &#8212; A core architectural choice is whether to learn via parameter changes (fine-tuning) or prompt changes (in-context learning/RAG). ICL is often faster and cheaper, especially as foundational models improve rapidly, making fine-tuned models quickly obsolete. While fine-tuning on synthetic data is an option for enterprises with privacy concerns, generating high-quality synthetic data is a significant challenge, often making prompt-based learning the more practical path.</p></li></ul><div class=\"subscription-widget-wrap-editor\"><div class=\"subscription-widget show-subscribe\"><div class=\"preamble\"><p class=\"cta-caption\">Thanks for reading Shrivu&#8217;s Substack! Subscribe for free to receive new posts and support my work.</p></div><form class=\"subscription-widget-subscribe\"><input class=\"email-input\" name=\"email\" tabindex=\"-1\" type=\"email\" /><input class=\"button primary\" type=\"submit\" value=\"Subscribe\" /><div class=\"fake-input-wrapper\"><div class=\"fake-input\"></div><div class=\"fake-button\"></div></div></form></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-1\" id=\"footnote-1\" target=\"_self\">1</a><div class=\"footnote-content\"><p>See Dwarkesh&#8217;s post on <a href=\"https://www.dwarkesh.com/i/165028925/continual-learning\">&#8220;Why I don&#8217;t think AGI is right around the corner&#8221;</a> particularly about continual learning. It&#8217;s truely a pretty critical gap with today&#8217;s agents and LLM-powered products but one that I&#8217;m pretty bullish is mostly solvable at a &#8220;scaffolding&#8221; layer (rather than a fundamental ceiling with LLMs).</p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-2\" id=\"footnote-2\" target=\"_self\">2</a><div class=\"footnote-content\"><p>I wrote this based on my own brainstorm of ideas and hope that this is mostly conclusive but there&#8217;s definitely a chance I missed some, let me know! </p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-3\" id=\"footnote-3\" target=\"_self\">3</a><div class=\"footnote-content\"><p>By calling both of these expensive&#8212;costs and latency-wise&#8212;I&#8217;m also implying this rationale will become less important over time but remains a medium-term design consideration.</p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-4\" id=\"footnote-4\" target=\"_self\">4</a><div class=\"footnote-content\"><p>See OpenAI&#8217;s <a href=\"https://openai.com/index/sycophancy-in-gpt-4o/\">&#8220;Sycophancy in GPT-4o&#8221;</a> kerfuffle. </p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-5\" id=\"footnote-5\" target=\"_self\">5</a><div class=\"footnote-content\"><p>For example, imagine a manager's private feedback, <em>\"Bob on Project Stardust often misses deadlines,\"</em> is naively anonymized for fine-tuning a global model. The model learns the association between the unique entity \"Project Stardust\" and the concept of \"missing deadlines.\" A later query from another user about \"Project Stardust\" could then elicit a response about engineers on that project struggling with deadlines, effectively leaking the substance of the private feedback even if the name \"Bob\" is masked.</p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-6\" id=\"footnote-6\" target=\"_self\">6</a><div class=\"footnote-content\"><p>This is one of those things that a lot of AI platform startups will say they can do this, but I haven&#8217;t seen anything yet that proves it can be done completely end-to-end while being something I&#8217;d trust in production.</p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-7\" id=\"footnote-7\" target=\"_self\">7</a><div class=\"footnote-content\"><p>There are several interesting parallels to the complexity of agent memory and the more well-studied occurrences of <a href=\"https://priorart.dev/articles/how-state-makes-software-complex/\">state-complexity in software engineering</a>. </p></div></div><div class=\"footnote\"><a class=\"footnote-number\" contenteditable=\"false\" href=\"https://blog.sshh.io/feed#footnote-anchor-8\" id=\"footnote-8\" target=\"_self\">8</a><div class=\"footnote-content\"><p>Contrary to popular belief, training LLMs to optimize their own preferences, when done carefully, can be a pretty powerful zero-data training technique. See <a href=\"https://arxiv.org/abs/2505.03335\">&#8220;Absolute Zero: Reinforced Self-play Reasoning with Zero Data&#8221;</a> and <a href=\"https://arxiv.org/abs/2506.10943\">&#8220;Self-Adapting Language Models&#8221;</a>.</p></div></div>"
            ],
            "link": "https://blog.sshh.io/p/how-to-train-your-gpt-wrapper",
            "publishedAt": "2025-06-28",
            "source": "Shrivu Shankar",
            "summary": "<p>One of the most common complaints I hear from users of AI agents is, \"Why do I have to tell it the same thing over and over?\" They expect their tools to learn from experience, but the reality is that most don't. This is because today's LLM-powered apps are fundamentally static; they don't learn purely from individual interactions.<a class=\"footnote-anchor\" href=\"https://blog.sshh.io/feed#footnote-1\" id=\"footnote-anchor-1\" target=\"_self\">1</a></p><p>As building agents becomes better defined and many products have shipped their first agentic MVPs, what&#8217;s becoming clear is that the next new thing may be how to get these agents to reliably and securely self-improve. This applies to both <strong>knowledge</strong> (gaining persistent user-related context) and <strong>behavior</strong> (learning to more effectively solve problems) which are independent but highly interrelated. In some online contexts, you&#8217;ll see this referred to as agent &#8220;memory,&#8221; and to me, that's just an implementation for achieving this experience.</p><p>If machine learning (ML) was supposed to &#8220;<a href=\"https://en.wikipedia.org/wiki/Machine_learning\">learn from experience E with respect to some class of tasks T</a>&#8230;&#8221; why are our GPT wrappers, built using ML, not actually learning from experience? The answer is: technically they could, but training these next-token-prediction models is actually a fairly non-trivial problem compared to their task-specific classification/regression/etc counterparts.</p><p>In this post,",
            "title": "How to Train Your GPT Wrapper"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2025-06-28"
}
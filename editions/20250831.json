{
    "articles": [
        {
            "content": [
                "<header>\n  <h1>Vibe Coding Terminal Editor</h1>\n  <time class=\"meta\" datetime=\"2025-08-31\">Aug 31, 2025</time>\n</header>\n<p>I \u201cwrote\u201d <a href=\"https://github.com/matklad/terminal-editor/\">a small tool</a> for myself as my biannual\nroutine check of where llms are currently at. I think I\u2019ve learned a bunch from this exercise. This\nis frustrating! I don\u2019t want to learn by trial and error, I\u2019d rather read someone\u2019s blog post with\nlessons learned. Sadly, <em>most</em> of the writing on the topic that percolates to me tends to be\nhigh-level \u2014 easy to nod along while reading, but hard to extract actionable lessons. So this is\nwhat I want to do here, list specific tricks learned.</p>\n<section id=\"Terminal-Editor\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Terminal-Editor\">Terminal Editor</a></h2>\n<p>Let me quickly introduce the project. It\u2019s a VS Code extension that allows me to run \u201cshell\u201d  inside\nmy normal editor widget, such that the output is normal text buffer where all standard\nmotion/editing commands work. So I can \u201cgoto definition\u201d on paths printed as a part of backtrace,\nuse multiple cursors to copy compiler\u2019s suggestions, or just <kbd><kbd>PageUp</kbd></kbd> / <kbd><kbd>PageDown</kbd></kbd> to\nscroll the output. If you are familiar with Emacs, it\u2019s\n<a href=\"https://www.gnu.org/software/emacs/manual/html_mono/eshell.html\">Eshell</a>, just worse:</p>\n\n<figure>\n\n<img alt=\"\" height=\"1086\" src=\"https://github.com/user-attachments/assets/acaf653e-a170-4685-8cce-5ca8dd31b9b4\" width=\"1398\" />\n</figure>\n<p>I now use <code>terminal-editor</code> to launch most of my compilation commands, as it has several niceties on\ntop of what my normal shell provides. For example, by default only the last 50 lines of output are\nshown, but I can hit tab to fold and unfold full output. Such a simple feature, but such a pain to\nimplement in a UNIX shell/terminal!</p>\n<p>What follows is an unstructured bag of things learned:</p>\n</section>\n<section id=\"Plan-Reset\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Plan-Reset\">Plan / Reset</a></h2>\n<p>I originally tried to use <code>claude</code> code normally, by iteratively prompting in the terminal until I\nget the output I want. This was frustrating, as it was too easy to miss a good place to commit a\nchunk of work, or to rein in a conversation going astray. This \u201cprompting-then-waiting\u201d mode also had\na pattern of mental context switches not matching my preferred style of work. This article suggests\na better workflow: <a class=\"display url\" href=\"https://harper.blog/2025/05/08/basic-claude-code/\">https://harper.blog/2025/05/08/basic-claude-code/</a></p>\n<p>Instead of writing your single prompt in the terminal, you write an entire course of action as a\ntask list in <code>plan.md</code> document, and the actual prompt is then something along the lines of</p>\n\n<figure class=\"blockquote\">\n<blockquote><p>Read @plan.md, complete the next task, and mark it with <code>X</code>.</p>\n</blockquote>\n\n</figure>\n<p>After <code>claude</code> finishes iterating on a step you look at the diff and interactively prompt for\nnecessary corrections. When you are happy, <code>git commit</code> and <code>/clear</code> the conversation, to start the\nnext step from the clean slate.</p>\n<p>The plan pattern reduces context switches, because it allows you to plan several steps ahead, while\nyou are in the planning mode, even if it makes sense to do the work one step at a time. I often also\nwork on continuing the plan when <code>claude</code> is working on the current task.</p>\n</section>\n<section id=\"Whiteboard-Agent-Metaphor\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Whiteboard-Agent-Metaphor\">Whiteboard / Agent Metaphor</a></h2>\n<p>A brilliant metaphor from another post\n<a class=\"display url\" href=\"https://crawshaw.io/blog/programming-with-agents\">https://crawshaw.io/blog/programming-with-agents</a>\nis that prompting LLM for some coding task and then expecting it to one-shot a working solution is\nquite a bit like asking a candidate to whiteboard an algorithm during the interview.</p>\n<p>LLMs are clearly superhuman at whiteboarding, but you can\u2019t go far without feedback. \u201cAgentic\u201d\nprogramming like <code>claude</code> allows LLMs to iterate on solution.</p>\n<p>LLMs are <em>much</em> better at whiteboarding than at iterating. My experience is that, starting with\nsuboptimal solution, LLM generally can\u2019t improve it by itself along the fuzzy aesthetic metrics I\ncare about. They can make valid changes, but the overall quality stays roughly the same.</p>\n<p>However, LLMs are tenacious, and can do a lot of iterations. If you <em>do</em> have a value function, you\ncan use it to extract useful work from random walk! A <em>bad</em> value function is human judgement.\nSitting in the loop with LLM and pointing out mistakes is both frustrating and slow (you are the\nbottleneck). In contrast \u201cmake this test green\u201d is very efficient at getting working (\u2260 good)\ncode.</p>\n</section>\n<section id=\"Spec-Is-Code-Is-Tests\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Spec-Is-Code-Is-Tests\">Spec Is Code Is Tests</a></h2>\n<p>LLMs are good at \u201cclosing the loop\u201d, they can make the ends meet. This insight combined with the\n<code>plan.md</code> pattern gives my current workflow \u2014 spec \u2194 code \u2194 test loop. Here\u2019s the story:</p>\n<p>I coded the first version of <code>terminal-editor</code> using just the <code>plan.md</code> pattern, but at some point I\nhit complexity wall. I realized that my original implementation strategy for syntax highlighting was\na dead end, and I needed to change it, but that was hard to do without making a complete mess of the\ncode. The accumulated <code>plan.md</code> reflected a bunch of historical detours, and the tests were too\nbrittle and coupled to the existing implementation (more on tests later). This worked for\nincremental additions, but now I wanted to change something in the middle.</p>\n<p>I realized that what I want is not an append-only <code>plan.md</code> that reflects history, but rather a\nmutable <code>spec.md</code> that describes clearly how the software should behave. For normal engineering,\nthis would have been \u201cdamn, I guess I need to throw one out and start afresh\u201d moment. With <code>claude</code>,\nI added <code>plan.md</code> and all the code to the context and asked it to write <code>spec.md</code> file in the same\ntask list format. There are two insights here:</p>\n<p><em>First</em>, mutable spec is a good way to instruct LLM. When I want to apply a change to\n<code>terminal-editor</code> now, I prompt <code>claude</code> to update the spec first (unchecking any items that need\nre-doing), manually review/touch-up the spec, and use a canned prompt to align the code and tests\nwith the spec.</p>\n<p><em>Second</em>, that you can think of an LLM as a machine translation, which can automatically convert\nbetween working code, specification, and tests. You can treat <em>any</em> of those things as an input, as\nif you are coding in <a href=\"https://minikanren.org\">miniKanren</a>!</p>\n</section>\n<section id=\"Tests\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Tests\">Tests</a></h2>\n<p>I did have this idea of closing the loop when I started with <code>terminal-editor</code>, so I crafted the\nprompts to emphasize testing. You can guess the result! <code>claude</code> wrote a lot of tests, following all\nthe modern \u201cbest practices\u201d \u2014 a deluge of unit tests that were just needlessly nailing down\ninternal API, a jungle of bug-hiding mocks, and a bunch of unfocused integration tests which were\nslow, flaky, and contained a copious amount of sleeps to paper over synchronization bugs. Really,\nthis was eerily similar to a typical test suite you can find in the wild. I am wondering why is\nthat?</p>\n<p>This is perhaps my main take away: if I am vibe-coding anything again, and I want to maintain it and\nnot just one-shot it, I will think very hard about the testing strategy. Really, to tout my own\nhorn, I think that perhaps <a href=\"https://matklad.github.io/2021/05/31/how-to-test.html\"><em>How to Test?</em></a>\nis the best article out there about agentic coding. Test iteration is a multiplier for humans, but a\nhard requirement for LLMs. Test must be very fast, non-flaky, and should end-to-end test application\n<em>features</em>, rather than code.</p>\n<p>Concretely, I just completely wiped out all the existing tests. Then I added testing strategy to the\nspec. There are two functions:</p>\n\n<figure class=\"code-block\">\n\n\n<pre><code><span class=\"line\"><span class=\"hl-keyword\">export</span> <span class=\"hl-keyword\">async</span> <span class=\"hl-keyword\">function</span> <span class=\"hl-title function_\">sync</span>(<span class=\"hl-params\"></span>): <span class=\"hl-title class_\">Promise</span>&lt;<span class=\"hl-built_in\">void</span>&gt;</span>\n<span class=\"line\"><span class=\"hl-keyword\">export</span> <span class=\"hl-keyword\">function</span> <span class=\"hl-title function_\">snapshot</span>(<span class=\"hl-params\"></span>): <span class=\"hl-built_in\">string</span></span></code></pre>\n\n</figure>\n<p>The <code>sync</code> function waits for all outstanding async work (like external processes) to finish. This\nrequires properly threading causality throughout the code. E.g., there\u2019s a promise you can <code>await</code>\non to join currently running process. The <code>snapshot</code> function captures the entire state of the\nextension as a single string. There\u2019s just one mock for the clock (another improvement on the\nusual terminal \u2014 process runtime is always show).</p>\n<p>Then, I prompted <code>claude</code> with something along the lines of</p>\n\n<figure class=\"blockquote\">\n<blockquote><p>Oups, looks like someone wiped out all the tests here, but the code and the spec look decent,\ncould you re-create the test suite using <code>snapshot</code> function as per @spec.md?</p>\n</blockquote>\n\n</figure>\n<p>It worked. Again, \u201cthrow one away\u201d is very cheap.</p>\n</section>\n<section id=\"Conclusions\">\n\n<h2><a href=\"https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html#Conclusions\">Conclusions</a></h2>\n<p>That\u2019s it! LLMs obviously can code. You need to hold them right. In particular, you need to engineer\na  feedback loop to let LLM iterate at its own pace. You don\u2019t want human in the \u201cdata plane\u201d of the\nloop, only in the control plane.\nLearn to <a href=\"https://matklad.github.io/2021/05/31/how-to-test.html\">architecture for testing</a>.</p>\n<p>LLM drastically reduce the activation energy for writing custom tools. I wanted something like\n<code>terminal-editor</code> forever, but it was never the most attractive yak to shave. Well, now I have the\nthing, I use it daily.</p>\n<p>LLMs don\u2019t magically solve all software engineering problems. The biggest time sink with\n<code>terminal-editor</code> was solving the <code>pty</code> problem, but LLMs are not yet at the \u201cgive me UNIX, but\nwithout <code>pty</code> mess\u201d stage.</p>\n<p>LLMs don\u2019t solve maintenance. A while ago I wrote about\n<a href=\"https://matklad.github.io/2024/12/13/majjit-lsp.html\"><em>LSP for jj</em></a>. I think I can actually code\nthat up in a day with Claude now? Not the proof of concept, the production version with everything\n<em>I</em> would need. But I don\u2019t want to <em>maintain</em> that. I don\u2019t want to context switch to fix a minor\nbug, if I am the only one using the tool. And, well, if I make this for other people, I\u2019d definitely\nbe on the hook for maintaining it :D</p>\n</section>"
            ],
            "link": "https://matklad.github.io/2025/08/31/vibe-coding-terminal-editor.html",
            "publishedAt": "2025-08-31",
            "source": "Alex Kladov",
            "summary": "I wrote a small tool for myself as my biannual routine check of where llms are currently at. I think I've learned a bunch from this exercise. This is frustrating! I don't want to learn by trial and error, I'd rather read someone's blog post with lessons learned. Sadly, most of the writing on the topic that percolates to me tends to be high-level --- easy to nod along while reading, but hard to extract actionable lessons. So this is what I want to do here, list specific tricks learned.",
            "title": "Vibe Coding Terminal Editor"
        }
    ],
    "lookbackDays": 1,
    "publishDate": "2025-08-31"
}